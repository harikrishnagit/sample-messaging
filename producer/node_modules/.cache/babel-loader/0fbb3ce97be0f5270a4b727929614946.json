{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2018 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crc16_1 = require(\"./crc16\");\n\nvar ed25519 = require(\"tweetnacl\");\n\nvar nkeys_1 = require(\"./nkeys\");\n\nvar util = require(\"./util\");\n\nvar base32_1 = require(\"./base32\");\n\nvar Codec =\n/** @class */\nfunction () {\n  function Codec() {}\n\n  Codec.encode = function (prefix, src) {\n    if (!Buffer.isBuffer(src)) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.SerializationError);\n    }\n\n    if (!nkeys_1.Prefixes.isValidPrefix(prefix)) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n    }\n\n    return Codec._encode(false, prefix, src);\n  };\n\n  Codec.encodeSeed = function (role, src) {\n    if (!nkeys_1.Prefixes.isValidPublicPrefix(role)) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n    }\n\n    if (!Buffer.isBuffer(src)) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.ApiError);\n    }\n\n    if (src.byteLength != ed25519.sign.seedLength) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidSeedLen);\n    }\n\n    return Codec._encode(true, role, src);\n  };\n\n  Codec.decode = function (expected, src) {\n    if (!nkeys_1.Prefixes.isValidPrefix(expected)) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n    }\n\n    var raw = Codec._decode(src);\n\n    if (raw[0] !== expected) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n    }\n\n    return raw.slice(1);\n  };\n\n  Codec.decodeSeed = function (src) {\n    var raw = Codec._decode(src);\n\n    var prefix = Codec._decodePrefix(raw);\n\n    if (prefix[0] != nkeys_1.Prefix.Seed) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidSeed);\n    }\n\n    if (!nkeys_1.Prefixes.isValidPublicPrefix(prefix[1])) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n    }\n\n    return {\n      buf: raw.slice(2),\n      prefix: prefix[1]\n    };\n  }; // unsafe encode no prefix/role validation\n\n\n  Codec._encode = function (seed, role, payload) {\n    // offsets for this token\n    var payloadOffset = seed ? 2 : 1;\n    var payloadLen = payload.byteLength;\n    var checkLen = 2;\n    var cap = payloadOffset + payloadLen + checkLen;\n    var checkOffset = payloadOffset + payloadLen;\n    var raw = Buffer.alloc(cap); // make the prefixes human readable when encoded\n\n    if (seed) {\n      var encodedPrefix = Codec._encodePrefix(nkeys_1.Prefix.Seed, role);\n\n      encodedPrefix.copy(raw, 0, 0);\n    } else {\n      raw[0] = role;\n    }\n\n    payload.copy(raw, payloadOffset, 0); //calculate the checksum write it LE\n\n    var checksum = crc16_1.crc16.checksum(raw.slice(0, checkOffset));\n    raw.writeUInt16LE(checksum, checkOffset);\n    return base32_1.base32.encode(raw);\n  }; // unsafe decode - no prefix/role validation\n\n\n  Codec._decode = function (src) {\n    if (src.byteLength < 4) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidEncoding);\n    }\n\n    var raw;\n\n    try {\n      raw = base32_1.base32.decode(src);\n    } catch (ex) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidEncoding, ex);\n    }\n\n    var checkOffset = raw.byteLength - 2;\n    var checksum = raw.readUInt16LE(checkOffset);\n    var payload = raw.slice(0, checkOffset);\n\n    if (!crc16_1.crc16.validate(payload, checksum)) {\n      throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidChecksum);\n    }\n\n    return payload;\n  };\n\n  Codec._encodePrefix = function (kind, role) {\n    // In order to make this human printable for both bytes, we need to do a little\n    // bit manipulation to setup for base32 encoding which takes 5 bits at a time.\n    var b1 = kind | role >> 5;\n    var b2 = (role & 31) << 3; // 31 = 00011111\n\n    return Buffer.from([b1, b2]);\n  };\n\n  Codec._decodePrefix = function (raw) {\n    // Need to do the reverse from the printable representation to\n    // get back to internal representation.\n    var b1 = raw[0] & 248; // 248 = 11111000\n\n    var b2 = (raw[0] & 7) << 5 | (raw[1] & 248) >> 3; // 7 = 00000111\n\n    var a = new Uint8Array(2);\n    a[0] = b1;\n    a[1] = b2;\n    return a;\n  };\n\n  Codec.toArrayBuffer = util.toArrayBuffer();\n  return Codec;\n}();\n\nexports.Codec = Codec;","map":{"version":3,"sources":["../../src/codec.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2018 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar crc16_1 = require(\"./crc16\");\nvar ed25519 = require(\"tweetnacl\");\nvar nkeys_1 = require(\"./nkeys\");\nvar util = require(\"./util\");\nvar base32_1 = require(\"./base32\");\nvar Codec = /** @class */ (function () {\n    function Codec() {\n    }\n    Codec.encode = function (prefix, src) {\n        if (!Buffer.isBuffer(src)) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.SerializationError);\n        }\n        if (!nkeys_1.Prefixes.isValidPrefix(prefix)) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n        }\n        return Codec._encode(false, prefix, src);\n    };\n    Codec.encodeSeed = function (role, src) {\n        if (!nkeys_1.Prefixes.isValidPublicPrefix(role)) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n        }\n        if (!Buffer.isBuffer(src)) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.ApiError);\n        }\n        if (src.byteLength != ed25519.sign.seedLength) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidSeedLen);\n        }\n        return Codec._encode(true, role, src);\n    };\n    Codec.decode = function (expected, src) {\n        if (!nkeys_1.Prefixes.isValidPrefix(expected)) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n        }\n        var raw = Codec._decode(src);\n        if (raw[0] !== expected) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n        }\n        return raw.slice(1);\n    };\n    Codec.decodeSeed = function (src) {\n        var raw = Codec._decode(src);\n        var prefix = Codec._decodePrefix(raw);\n        if (prefix[0] != nkeys_1.Prefix.Seed) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidSeed);\n        }\n        if (!nkeys_1.Prefixes.isValidPublicPrefix(prefix[1])) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidPrefixByte);\n        }\n        return ({ buf: raw.slice(2), prefix: prefix[1] });\n    };\n    // unsafe encode no prefix/role validation\n    Codec._encode = function (seed, role, payload) {\n        // offsets for this token\n        var payloadOffset = seed ? 2 : 1;\n        var payloadLen = payload.byteLength;\n        var checkLen = 2;\n        var cap = payloadOffset + payloadLen + checkLen;\n        var checkOffset = payloadOffset + payloadLen;\n        var raw = Buffer.alloc(cap);\n        // make the prefixes human readable when encoded\n        if (seed) {\n            var encodedPrefix = Codec._encodePrefix(nkeys_1.Prefix.Seed, role);\n            encodedPrefix.copy(raw, 0, 0);\n        }\n        else {\n            raw[0] = role;\n        }\n        payload.copy(raw, payloadOffset, 0);\n        //calculate the checksum write it LE\n        var checksum = crc16_1.crc16.checksum(raw.slice(0, checkOffset));\n        raw.writeUInt16LE(checksum, checkOffset);\n        return base32_1.base32.encode(raw);\n    };\n    // unsafe decode - no prefix/role validation\n    Codec._decode = function (src) {\n        if (src.byteLength < 4) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidEncoding);\n        }\n        var raw;\n        try {\n            raw = base32_1.base32.decode(src);\n        }\n        catch (ex) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidEncoding, ex);\n        }\n        var checkOffset = raw.byteLength - 2;\n        var checksum = raw.readUInt16LE(checkOffset);\n        var payload = raw.slice(0, checkOffset);\n        if (!crc16_1.crc16.validate(payload, checksum)) {\n            throw new nkeys_1.NKeysError(nkeys_1.NKeysErrorCode.InvalidChecksum);\n        }\n        return payload;\n    };\n    Codec._encodePrefix = function (kind, role) {\n        // In order to make this human printable for both bytes, we need to do a little\n        // bit manipulation to setup for base32 encoding which takes 5 bits at a time.\n        var b1 = kind | (role >> 5);\n        var b2 = (role & 31) << 3; // 31 = 00011111\n        return Buffer.from([b1, b2]);\n    };\n    Codec._decodePrefix = function (raw) {\n        // Need to do the reverse from the printable representation to\n        // get back to internal representation.\n        var b1 = raw[0] & 248; // 248 = 11111000\n        var b2 = (raw[0] & 7) << 5 | ((raw[1] & 248) >> 3); // 7 = 00000111\n        var a = new Uint8Array(2);\n        a[0] = b1;\n        a[1] = b2;\n        return a;\n    };\n    Codec.toArrayBuffer = util.toArrayBuffer();\n    return Codec;\n}());\nexports.Codec = Codec;\n//# sourceMappingURL=codec.js.map"]},"metadata":{},"sourceType":"script"}