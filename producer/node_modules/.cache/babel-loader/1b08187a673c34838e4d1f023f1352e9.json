{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2018 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // Fork of https://github.com/LinusU/base32-encode\n// and https://github.com/LinusU/base32-decode to support returning\n// buffers without padding.\n\nvar base32 =\n/** @class */\nfunction () {\n  function base32() {}\n\n  base32.encode = function (src) {\n    var bits = 0;\n    var value = 0;\n    var a = new Uint8Array(src);\n    var buf = Buffer.allocUnsafe(src.byteLength * 2);\n    var j = 0;\n\n    for (var i = 0; i < a.byteLength; i++) {\n      value = value << 8 | a[i];\n      bits += 8;\n\n      while (bits >= 5) {\n        var index = value >>> bits - 5 & 31;\n        buf[j++] = base32.alphabet.charAt(index).charCodeAt(0);\n        bits -= 5;\n      }\n    }\n\n    if (bits > 0) {\n      var index = value << 5 - bits & 31;\n      buf[j++] = base32.alphabet.charAt(index).charCodeAt(0);\n    }\n\n    return buf.slice(0, j);\n  };\n\n  base32.decode = function (src) {\n    var bits = 0;\n    var byte = 0;\n    var j = 0;\n    var a = new Uint8Array(src);\n    var out = Buffer.alloc(a.byteLength * 5 / 8 | 0);\n\n    for (var i = 0; i < a.byteLength; i++) {\n      var v = String.fromCharCode(a[i]);\n      var vv = base32.alphabet.indexOf(v);\n\n      if (vv === -1) {\n        throw new Error(\"Illegal Base32 character: \" + a[i]);\n      }\n\n      byte = byte << 5 | vv;\n      bits += 5;\n\n      if (bits >= 8) {\n        out[j++] = byte >>> bits - 8 & 255;\n        bits -= 8;\n      }\n    }\n\n    return out.slice(0, j);\n  };\n\n  base32.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n  return base32;\n}();\n\nexports.base32 = base32;","map":{"version":3,"sources":["../../src/base32.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;AAaG;;;;IAGH;AACA;AACA;;AAEA,IAAA,MAAA;AAAA;AAAA,YAAA;AAAA,WAAA,MAAA,GAAA,CA8CC;;AA3CU,EAAA,MAAA,CAAA,MAAA,GAAP,UAAc,GAAd,EAAyB;AACrB,QAAI,IAAI,GAAG,CAAX;AACA,QAAI,KAAK,GAAG,CAAZ;AACA,QAAI,CAAC,GAAG,IAAI,UAAJ,CAAe,GAAf,CAAR;AACA,QAAI,GAAG,GAAG,MAAM,CAAC,WAAP,CAAmB,GAAG,CAAC,UAAJ,GAAe,CAAlC,CAAV;AACA,QAAI,CAAC,GAAG,CAAR;;AACA,SAAI,IAAI,CAAC,GAAC,CAAV,EAAa,CAAC,GAAG,CAAC,CAAC,UAAnB,EAA+B,CAAC,EAAhC,EAAoC;AAChC,MAAA,KAAK,GAAI,KAAK,IAAI,CAAV,GAAe,CAAC,CAAC,CAAD,CAAxB;AACA,MAAA,IAAI,IAAI,CAAR;;AACA,aAAM,IAAI,IAAI,CAAd,EAAiB;AACb,YAAI,KAAK,GAAI,KAAK,KAAM,IAAI,GAAG,CAAnB,GAAyB,EAArC;AACA,QAAA,GAAG,CAAC,CAAC,EAAF,CAAH,GAAW,MAAM,CAAC,QAAP,CAAgB,MAAhB,CAAuB,KAAvB,EAA8B,UAA9B,CAAyC,CAAzC,CAAX;AACA,QAAA,IAAI,IAAI,CAAR;AACH;AACJ;;AACD,QAAI,IAAI,GAAG,CAAX,EAAc;AACV,UAAI,KAAK,GAAI,KAAK,IAAK,IAAI,IAAf,GAAwB,EAApC;AACA,MAAA,GAAG,CAAC,CAAC,EAAF,CAAH,GAAW,MAAM,CAAC,QAAP,CAAgB,MAAhB,CAAuB,KAAvB,EAA8B,UAA9B,CAAyC,CAAzC,CAAX;AACH;;AACD,WAAO,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAY,CAAZ,CAAP;AACH,GApBM;;AAsBA,EAAA,MAAA,CAAA,MAAA,GAAP,UAAc,GAAd,EAAyB;AACrB,QAAI,IAAI,GAAG,CAAX;AACA,QAAI,IAAI,GAAG,CAAX;AACA,QAAI,CAAC,GAAG,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,UAAJ,CAAe,GAAf,CAAR;AACA,QAAI,GAAG,GAAG,MAAM,CAAC,KAAP,CAAa,CAAC,CAAC,UAAF,GAAe,CAAf,GAAmB,CAAnB,GAAuB,CAApC,CAAV;;AACA,SAAI,IAAI,CAAC,GAAC,CAAV,EAAa,CAAC,GAAG,CAAC,CAAC,UAAnB,EAA+B,CAAC,EAAhC,EAAoC;AAChC,UAAI,CAAC,GAAG,MAAM,CAAC,YAAP,CAAoB,CAAC,CAAC,CAAD,CAArB,CAAR;AACA,UAAI,EAAE,GAAG,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAAwB,CAAxB,CAAT;;AACA,UAAG,EAAE,KAAK,CAAC,CAAX,EAAc;AACV,cAAM,IAAI,KAAJ,CAAU,+BAA+B,CAAC,CAAC,CAAD,CAA1C,CAAN;AACH;;AACD,MAAA,IAAI,GAAI,IAAI,IAAI,CAAT,GAAc,EAArB;AACA,MAAA,IAAI,IAAI,CAAR;;AACA,UAAG,IAAI,IAAI,CAAX,EAAc;AACV,QAAA,GAAG,CAAC,CAAC,EAAF,CAAH,GAAY,IAAI,KAAM,IAAI,GAAG,CAAlB,GAAwB,GAAnC;AACA,QAAA,IAAI,IAAI,CAAR;AACH;AACJ;;AACD,WAAO,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAP;AACH,GApBM;;AAxBA,EAAA,MAAA,CAAA,QAAA,GAAW,kCAAX;AA6CX,SAAA,MAAA;AAAC,CA9CD,EAAA;;AAAa,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2018 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Fork of https://github.com/LinusU/base32-encode\n// and https://github.com/LinusU/base32-decode to support returning\n// buffers without padding.\nvar base32 = /** @class */ (function () {\n    function base32() {\n    }\n    base32.encode = function (src) {\n        var bits = 0;\n        var value = 0;\n        var a = new Uint8Array(src);\n        var buf = Buffer.allocUnsafe(src.byteLength * 2);\n        var j = 0;\n        for (var i = 0; i < a.byteLength; i++) {\n            value = (value << 8) | a[i];\n            bits += 8;\n            while (bits >= 5) {\n                var index = (value >>> (bits - 5)) & 31;\n                buf[j++] = base32.alphabet.charAt(index).charCodeAt(0);\n                bits -= 5;\n            }\n        }\n        if (bits > 0) {\n            var index = (value << (5 - bits)) & 31;\n            buf[j++] = base32.alphabet.charAt(index).charCodeAt(0);\n        }\n        return buf.slice(0, j);\n    };\n    base32.decode = function (src) {\n        var bits = 0;\n        var byte = 0;\n        var j = 0;\n        var a = new Uint8Array(src);\n        var out = Buffer.alloc(a.byteLength * 5 / 8 | 0);\n        for (var i = 0; i < a.byteLength; i++) {\n            var v = String.fromCharCode(a[i]);\n            var vv = base32.alphabet.indexOf(v);\n            if (vv === -1) {\n                throw new Error(\"Illegal Base32 character: \" + a[i]);\n            }\n            byte = (byte << 5) | vv;\n            bits += 5;\n            if (bits >= 8) {\n                out[j++] = (byte >>> (bits - 8)) & 255;\n                bits -= 8;\n            }\n        }\n        return out.slice(0, j);\n    };\n    base32.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n    return base32;\n}());\nexports.base32 = base32;\n//# sourceMappingURL=base32.js.map"]},"metadata":{},"sourceType":"script"}