{"ast":null,"code":"/*\n * Copyright 2013-2020 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint no-sync: 0 */\n'use strict';\n/**\n * Module Dependencies\n */\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst util = require('util');\n\nconst events = require('events');\n\nconst nuid = require('nuid');\n\nconst nkeys = require('ts-nkeys');\n\nconst fs = require('fs');\n\nconst url = require('url');\n/**\n * Constants\n */\n\n\nconst VERSION = require('../package.json').version;\n\nconst DEFAULT_PORT = 4222;\nconst DEFAULT_PRE = 'nats://localhost:';\nconst DEFAULT_URI = DEFAULT_PRE + DEFAULT_PORT;\nconst MAX_CONTROL_LINE_SIZE = 4096; // Parser state\n\nconst AWAITING_CONTROL = 0;\nconst AWAITING_MSG_PAYLOAD = 1; // Reconnect Parameters, 2 sec wait, 10 tries\n\nconst DEFAULT_RECONNECT_TIME_WAIT = 2 * 1000;\nconst DEFAULT_MAX_RECONNECT_ATTEMPTS = 10;\nconst DEFAULT_RECONNECT_JITTER = 100;\nconst DEFAULT_RECONNECT_JITTER_TLS = 1000; // Ping interval\n\nconst DEFAULT_PING_INTERVAL = 2 * 60 * 1000; // 2 minutes\n\nconst DEFAULT_MAX_PING_OUT = 2; // Protocol\n\nconst MSG = /^MSG\\s+([^\\s\\r\\n]+)\\s+([^\\s\\r\\n]+)\\s+(([^\\s\\r\\n]+)[^\\S\\r\\n]+)?(\\d+)\\r\\n/i;\nconst OK = /^\\+OK\\s*\\r\\n/i;\nconst ERR = /^-ERR\\s+('.+')?\\r\\n/i;\nconst PING = /^PING\\r\\n/i;\nconst PONG = /^PONG\\r\\n/i;\nconst INFO = /^INFO\\s+([^\\r\\n]+)\\r\\n/i;\nconst SUBRE = /^SUB\\s+([^\\r\\n]+)\\r\\n/i;\nconst CREDS = /\\s*(?:(?:[-]{3,}[^\\n]*[-]{3,}\\n)(.+)(?:\\n\\s*[-]{3,}[^\\n]*[-]{3,}\\n))/i;\nconst CR_LF = '\\r\\n';\nconst CR_LF_LEN = CR_LF.length;\nconst EMPTY = '';\nconst SPC = ' '; // Protocol\n\nconst SUB = 'SUB';\nconst UNSUB = 'UNSUB';\nconst CONNECT = 'CONNECT'; // Responses\n\nconst PING_REQUEST = 'PING' + CR_LF;\nconst PONG_RESPONSE = 'PONG' + CR_LF; // Errors\n\nconst BAD_AUTHENTICATION = 'BAD_AUTHENTICATION';\nconst BAD_CALLBACK = 'BAD_CALLBACK';\nconst BAD_CREDS = 'BAD_CREDENTIALS';\nconst BAD_JSON = 'BAD_JSON';\nconst BAD_MSG = 'BAD_MSG';\nconst BAD_OPTIONS = 'BAD_OPTIONS';\nconst BAD_REPLY = 'BAD_REPLY';\nconst BAD_SUBJECT = 'BAD_SUBJECT';\nconst BAD_TIMEOUT = 'BAD_TIMEOUT';\nconst CLIENT_CERT_REQ = 'CLIENT_CERT_REQ';\nconst CONN_CLOSED = 'CONN_CLOSED';\nconst CONN_DRAINING = 'CONN_DRAINING';\nconst CONN_ERR = 'CONN_ERR';\nconst CONN_TIMEOUT = 'CONN_TIMEOUT';\nconst DISCONNECT_ERR = 'DISCONNECT';\nconst INVALID_ENCODING = 'INVALID_ENCODING';\nconst NATS_PROTOCOL_ERR = 'NATS_PROTOCOL_ERR';\nconst NKEY_OR_JWT_REQ = 'NKEY_OR_JWT_REQ';\nconst NO_ECHO_NOT_SUPPORTED = 'NO_ECHO_NOT_SUPPORTED';\nconst NO_SEED_IN_CREDS = 'NO_SEED_IN_CREDS';\nconst NO_USER_JWT_IN_CREDS = 'NO_USER_JWT_IN_CREDS';\nconst NON_SECURE_CONN_REQ = 'NON_SECURE_CONN_REQ';\nconst OPENSSL_ERR = 'OPENSSL_ERR';\nconst PERMISSIONS_ERR = 'permissions violation';\nconst REQ_TIMEOUT = 'REQ_TIMEOUT';\nconst SECURE_CONN_REQ = 'SECURE_CONN_REQ';\nconst SIGCB_NOTFUNC = 'SIG_NOT_FUNC';\nconst SIGNATURE_REQUIRED = 'SIG_REQ';\nconst STALE_CONNECTION_ERR = 'stale connection';\nconst SUB_DRAINING = 'SUB_DRAINING';\nconst BAD_AUTHENTICATION_MSG = 'User and Token can not both be provided';\nconst BAD_AUTHENTICATION_TH_FAILED_MSG_PREFIX = 'tokenHandler call failed: ';\nconst BAD_AUTHENTICATION_TH_NOT_FUNC_MSG = 'tokenHandler must be a function returning a token';\nconst BAD_AUTHENTICATION_T_AND_TH_MSG = 'token and tokenHandler cannot both be provided';\nconst BAD_CALLBACK_MSG = 'Bad callback';\nconst BAD_CREDS_MSG = 'Bad user credentials';\nconst BAD_JSON_MSG = 'Message should be a non-circular JSON-serializable value';\nconst BAD_MSG_MSG = 'Message can\\'t be a function';\nconst BAD_OPTIONS_MSG = 'Options should be an object.';\nconst BAD_REPLY_MSG = 'Reply can\\'t be a function';\nconst BAD_SUBJECT_MSG = 'Subject must be supplied';\nconst BAD_TIMEOUT_MSG = 'Timeout should be a number';\nconst CLIENT_CERT_REQ_MSG = 'Server requires a client certificate.';\nconst CONN_CLOSED_MSG = 'Connection closed';\nconst CONN_DRAINING_MSG = 'Connection draining';\nconst CONN_ERR_MSG_PREFIX = 'Could not connect to server: ';\nconst CONN_TIMEOUT_MSG = 'Connection timeout';\nconst DISCONNECT_MSG = 'Client disconnected, flush was reset';\nconst INVALID_ENCODING_MSG_PREFIX = 'Invalid Encoding:';\nconst NKEY_OR_JWT_REQ_MSG = 'An Nkey or User JWT callback needs to be defined.';\nconst NON_SECURE_CONN_REQ_MSG = 'Server does not support a secure connection.';\nconst NO_ECHO_NOT_SUPPORTED_MSG = 'echo is not supported';\nconst NO_SEED_IN_CREDS_MSG = 'Can not locate signing key in credentials';\nconst NO_USER_JWT_IN_CREDS_MSG = 'Can not locate user jwt in credentials.';\nconst OPENSSL_ERR_MSG_PREFIX = 'TLS credentials verification failed: ';\nconst REQ_TIMEOUT_MSG_PREFIX = 'The request timed out for subscription id: ';\nconst SECURE_CONN_REQ_MSG = 'Server requires a secure connection.';\nconst SIGCB_NOTFUNC_MSG = 'Signature callback is not a function.';\nconst SIGNATURE_REQUIRED_MSG = 'Server requires an Nkey signature.';\nconst SUB_DRAINING_MSG = 'Subscription draining';\nconst FLUSH_THRESHOLD = 65536;\n/**\n * @param {String} message\n * @param {String} code\n * @param {Error} [chainedError]\n * @constructor\n *\n * @api private\n */\n\nfunction NatsError(message, code, chainedError) {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n  this.code = code; // noinspection JSUnusedGlobalSymbols\n\n  this.chainedError = chainedError;\n}\n\nutil.inherits(NatsError, Error);\nexports.NatsError = NatsError;\n/**\n * Library Version\n */\n\nexports.version = VERSION;\n/**\n * Error codes\n */\n\nexports.BAD_AUTHENTICATION = BAD_AUTHENTICATION;\nexports.BAD_CALLBACK = BAD_CALLBACK;\nexports.BAD_CREDS = BAD_CREDS;\nexports.BAD_JSON = BAD_JSON;\nexports.BAD_MSG = BAD_MSG;\nexports.BAD_OPTIONS = BAD_OPTIONS;\nexports.BAD_REPLY = BAD_REPLY;\nexports.BAD_SUBJECT = BAD_SUBJECT;\nexports.BAD_TIMEOUT = BAD_TIMEOUT;\nexports.CLIENT_CERT_REQ = CLIENT_CERT_REQ;\nexports.CONN_CLOSED = CONN_CLOSED;\nexports.CONN_DRAINING = CONN_DRAINING;\nexports.CONN_ERR = CONN_ERR;\nexports.CONN_TIMEOUT = CONN_TIMEOUT;\nexports.INVALID_ENCODING = INVALID_ENCODING;\nexports.NATS_PROTOCOL_ERR = NATS_PROTOCOL_ERR;\nexports.NKEY_OR_JWT_REQ = NKEY_OR_JWT_REQ;\nexports.NON_SECURE_CONN_REQ = NON_SECURE_CONN_REQ;\nexports.NO_ECHO_NOT_SUPPORTED = NO_ECHO_NOT_SUPPORTED;\nexports.NO_SEED_IN_CREDS = NO_SEED_IN_CREDS;\nexports.NO_USER_JWT_IN_CREDS = NO_USER_JWT_IN_CREDS;\nexports.OPENSSL_ERR = OPENSSL_ERR;\nexports.PERMISSIONS_ERR = PERMISSIONS_ERR;\nexports.REQ_TIMEOUT = REQ_TIMEOUT;\nexports.SECURE_CONN_REQ = SECURE_CONN_REQ;\nexports.SIGCB_NOTFUNC = SIGCB_NOTFUNC;\nexports.SIGNATURE_REQUIRED = SIGNATURE_REQUIRED;\nexports.STALE_CONNECTION_ERR = STALE_CONNECTION_ERR;\nexports.SUB_DRAINING = SUB_DRAINING;\n/**\n * Create a properly formatted inbox subject.\n *\n * @api public\n */\n\nconst createInbox = exports.createInbox = function () {\n  return '_INBOX.' + nuid.next();\n};\n/**\n * Initialize a client with the appropriate options.\n *\n * @param {Object} [opts]\n * @api public\n */\n\n\nfunction Client(opts) {\n  events.EventEmitter.call(this);\n  this.parseOptions(opts);\n  this.initState(); // Select a server to connect to.\n\n  this.selectServer();\n  this.createConnection();\n}\n/**\n * Connect to a nats-server and return the client.\n * Argument can be a url, or an object with a 'url'\n * property and additional options.\n *\n * @params {Mixed} [url] - Url, port, or options object\n * @params {Object} [opts] - Options\n * @api public\n */\n\n\nexports.connect = function (url, opts) {\n  // If we receive one parameter, parser will\n  // figure out intent. If we provided opts, then\n  // first parameter should be url, and second an\n  // options object.\n  if (opts !== undefined) {\n    if (typeof opts !== 'object') {\n      throw new NatsError(BAD_OPTIONS_MSG, BAD_OPTIONS);\n    }\n\n    opts.url = sanitizeUrl(url);\n  } else {\n    opts = url;\n  }\n\n  return new Client(opts);\n};\n/**\n * Connected clients are event emitters.\n */\n\n\nutil.inherits(Client, events.EventEmitter);\n/**\n * Allow createInbox to be called on a client.\n *\n * @api public\n */\n\nClient.prototype.createInbox = createInbox;\n\nClient.prototype.assignOption = function (opts, prop, assign) {\n  if (assign === undefined) {\n    assign = prop;\n  }\n\n  if (opts[prop] !== undefined) {\n    this.options[assign] = opts[prop];\n  }\n};\n\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n\n  return array;\n}\n/**\n * Parse the constructor/connect options.\n *\n * @param {Object} [opts]\n * @api private\n */\n\n\nClient.prototype.parseOptions = function (opts) {\n  const options = this.options = {\n    encoding: 'utf8',\n    maxPingOut: DEFAULT_MAX_PING_OUT,\n    maxReconnectAttempts: DEFAULT_MAX_RECONNECT_ATTEMPTS,\n    noEcho: false,\n    pedantic: false,\n    pingInterval: DEFAULT_PING_INTERVAL,\n    reconnect: true,\n    reconnectTimeWait: DEFAULT_RECONNECT_TIME_WAIT,\n    reconnectJitter: DEFAULT_RECONNECT_JITTER,\n    reconnectJitterTLS: DEFAULT_RECONNECT_JITTER_TLS,\n    tls: false,\n    useOldRequestStyle: false,\n    verbose: false,\n    waitOnFirstConnect: false\n  };\n\n  if (undefined === opts) {\n    options.url = DEFAULT_URI;\n  } else if (typeof opts === 'number') {\n    options.url = DEFAULT_PRE + opts;\n  } else if (typeof opts === 'string') {\n    options.url = sanitizeUrl(opts);\n  } else if (typeof opts === 'object') {\n    if (opts.port !== undefined) {\n      options.url = DEFAULT_PRE + opts.port;\n    } // Pull out various options here\n\n\n    this.assignOption(opts, 'timeout');\n    this.assignOption(opts, 'encoding');\n    this.assignOption(opts, 'json');\n    this.assignOption(opts, 'maxPingOut');\n    this.assignOption(opts, 'maxReconnectAttempts');\n    this.assignOption(opts, 'name');\n    this.assignOption(opts, 'nkey');\n    this.assignOption(opts, 'noEcho');\n    this.assignOption(opts, 'noRandomize');\n    this.assignOption(opts, 'nonceSigner');\n    this.assignOption(opts, 'pass');\n    this.assignOption(opts, 'pedantic');\n    this.assignOption(opts, 'pingInterval');\n    this.assignOption(opts, 'preserveBuffers');\n    this.assignOption(opts, 'reconnect');\n    this.assignOption(opts, 'reconnectJitter');\n    this.assignOption(opts, 'reconnectJitterTLS');\n    this.assignOption(opts, 'reconnectDelayHandler');\n    this.assignOption(opts, 'reconnectTimeWait');\n    this.assignOption(opts, 'servers');\n    this.assignOption(opts, 'tls');\n    this.assignOption(opts, 'token');\n    this.assignOption(opts, 'tokenHandler');\n    this.assignOption(opts, 'url');\n    this.assignOption(opts, 'useOldRequestStyle');\n    this.assignOption(opts, 'user');\n    this.assignOption(opts, 'userCreds');\n    this.assignOption(opts, 'userJWT');\n    this.assignOption(opts, 'verbose');\n    this.assignOption(opts, 'waitOnFirstConnect');\n    this.assignOption(opts, 'yieldTime'); // fixme: aliasing a configuration property name should be an error\n\n    this.assignOption(opts, 'client', 'name');\n    this.assignOption(opts, 'credentials', 'userCreds');\n    this.assignOption(opts, 'dontRandomize', 'noRandomize');\n    this.assignOption(opts, 'jwt', 'userJWT');\n    this.assignOption(opts, 'JWT', 'userJWT');\n    this.assignOption(opts, 'nkeys', 'nkey');\n    this.assignOption(opts, 'NoRandomize', 'noRandomize');\n    this.assignOption(opts, 'password', 'pass');\n    this.assignOption(opts, 'secure', 'tls');\n    this.assignOption(opts, 'sig', 'nonceSigner');\n    this.assignOption(opts, 'sigCB', 'nonceSigner');\n    this.assignOption(opts, 'sigCallback', 'nonceSigner');\n    this.assignOption(opts, 'sigcb', 'nonceSigner');\n    this.assignOption(opts, 'uri', 'url');\n    this.assignOption(opts, 'urls', 'servers');\n    this.assignOption(opts, 'usercreds', 'userCreds');\n    this.assignOption(opts, 'userjwt', 'userJWT');\n  } // Set user/pass as needed if in options.\n\n\n  this.user = options.user;\n  this.pass = options.pass; // Set token as needed if in options.\n\n  this.token = options.token;\n  this.tokenHandler = options.tokenHandler; // Authentication - make sure authentication is valid.\n\n  if (this.user && this.token) {\n    throw new NatsError(BAD_AUTHENTICATION_MSG, BAD_AUTHENTICATION);\n  }\n\n  if (this.tokenHandler && typeof this.tokenHandler !== 'function') {\n    throw new NatsError(BAD_AUTHENTICATION_TH_NOT_FUNC_MSG, BAD_AUTHENTICATION);\n  }\n\n  if (this.tokenHandler && this.token) {\n    throw new NatsError(BAD_AUTHENTICATION_T_AND_TH_MSG, BAD_AUTHENTICATION);\n  }\n\n  if (options.reconnectDelayHandler && typeof options.reconnectDelayHandler !== 'function') {\n    throw new NatsError(BAD_OPTIONS, 'reconnectDelayHandler must be a function');\n  }\n\n  if (!options.reconnectDelayHandler) {\n    options.reconnectDelayHandler = jitter(options);\n  } // Encoding - make sure its valid.\n\n\n  if (Buffer.isEncoding(options.encoding)) {\n    this.encoding = options.encoding;\n  } else {\n    throw new NatsError(INVALID_ENCODING_MSG_PREFIX + options.encoding, INVALID_ENCODING);\n  } // For cluster support\n\n\n  this.servers = [];\n\n  if (Array.isArray(options.servers)) {\n    options.servers.forEach(server => {\n      server = sanitizeUrl(server);\n      this.servers.push(new Server(new url.URL(server)));\n    }); // Randomize if needed\n\n    if (options.noRandomize !== true) {\n      shuffle(this.servers);\n    } // if they gave an URL we should add it if different\n\n\n    if (options.url !== undefined && this.servers.indexOf(options.url) === -1) {\n      // Make url first element so it is attempted first\n      this.servers.unshift(new Server(new url.URL(options.url)));\n    }\n  } else {\n    if (undefined === options.url) {\n      options.url = DEFAULT_URI;\n    }\n\n    this.servers.push(new Server(new url.URL(options.url)));\n  } // If we are not setup for tls, but were handed a url with a tls:// prefix\n  // then upgrade to tls.\n\n\n  if (options.tls === false) {\n    this.servers.forEach(server => {\n      if (server.url.protocol === 'tls' || server.url.protocol === 'tls:') {\n        options.tls = true;\n      }\n    });\n  }\n\n  if (options.timeout && typeof options.timeout !== 'number') {\n    throw new NatsError('timeout should be a number', BAD_OPTIONS);\n  }\n};\n\nfunction jitter(options) {\n  return function () {\n    let extra = options.tls ? options.reconnectJitterTLS : options.reconnectJitter;\n\n    if (extra) {\n      extra++;\n      extra = Math.floor(Math.random() * extra);\n    }\n\n    return options.reconnectTimeWait + extra;\n  };\n}\n\nfunction sanitizeUrl(host) {\n  if (/^.*:\\/\\/.*/.exec(host) === null) {\n    // Does not have a scheme.\n    host = 'nats://' + host;\n  }\n\n  const u = new url.URL(host);\n\n  if (u.port === null || u.port === '') {\n    host += ':' + DEFAULT_PORT;\n  }\n\n  return host;\n}\n/**\n * Create a new server.\n *\n * @api private\n */\n\n\nfunction Server(url) {\n  this.url = url;\n  this.didConnect = false;\n  this.reconnects = 0;\n  this.lastConnect = 0;\n}\n/**\n * @api private\n */\n\n\nServer.prototype.toString = function () {\n  return this.url.href;\n};\n/**\n * Properly select the next server.\n * We rotate the server list as we go,\n * we also pull auth from urls as needed, or\n * if they were set in options use that as override.\n *\n * @api private\n */\n\n\nClient.prototype.selectServer = function () {\n  const server = this.servers.shift(); // Place in client context.\n\n  this.currentServer = server;\n  this.url = server.url;\n  const un = server.url.username || '';\n  const pw = server.url.password || '';\n  let up = '';\n\n  if (un !== '' && pw !== '') {\n    up = un + ':' + pw;\n  } else if (un !== '') {\n    up = un;\n  }\n\n  if (up !== '') {\n    const auth = up.split(':');\n\n    if (auth.length !== 1) {\n      if (this.options.user === undefined) {\n        this.user = auth[0];\n      }\n\n      if (this.options.pass === undefined) {\n        this.pass = auth[1];\n      }\n    } else {\n      if (this.options.token === undefined) {\n        this.token = auth[0];\n      }\n    }\n  }\n\n  this.servers.push(server);\n  return server;\n};\n\nClient.prototype.checkNoEchoMismatch = function () {\n  if ((this.info.proto === undefined || this.info.proto < 1) && this.options.noEcho) {\n    this.emit('error', new NatsError(NO_ECHO_NOT_SUPPORTED_MSG, NO_ECHO_NOT_SUPPORTED));\n    this.closeStream();\n    return true;\n  }\n\n  return false;\n};\n/**\n * Check for TLS configuration mismatch.\n *\n * @api private\n */\n\n\nClient.prototype.checkTLSMismatch = function () {\n  // Switch over to TLS as needed on the fly.\n  if (this.info.tls_required === true || this.options.tls !== false && this.stream.encrypted !== true) {\n    if (undefined === this.options.tls || this.options.tls === false) {\n      this.options.tls = true;\n    }\n  }\n\n  if (this.info.tls_required === true && this.options.tls === false) {\n    this.emit('error', new NatsError(SECURE_CONN_REQ_MSG, SECURE_CONN_REQ));\n    this.closeStream();\n    return true;\n  }\n\n  if (!this.info.tls_required && this.options.tls !== false) {\n    this.emit('error', new NatsError(NON_SECURE_CONN_REQ_MSG, NON_SECURE_CONN_REQ));\n    this.closeStream();\n    return true;\n  }\n\n  if (this.info.tls_verify === true && this.options.tls.cert === undefined) {\n    this.emit('error', new NatsError(CLIENT_CERT_REQ_MSG, CLIENT_CERT_REQ));\n    this.closeStream();\n    return true;\n  }\n\n  return false;\n};\n/**\n * Load a user jwt from a chained credential file.\n * @return {String | undefined}\n * @emits NatsError if JWT couldn't be parsed\n * @api private\n */\n\n\nClient.prototype.loadUserJWT = function () {\n  const contents = fs.readFileSync(this.options.userCreds).toString();\n  const m = CREDS.exec(contents); // jwt\n\n  if (m === null) {\n    this.emit('error', new NatsError(NO_USER_JWT_IN_CREDS_MSG, NO_USER_JWT_IN_CREDS));\n    this.closeStream();\n    return;\n  }\n\n  return m[1];\n};\n/**\n * Load a user nkey seed from a chained credential file\n * and sign nonce.\n *\n * @api private\n */\n\n\nClient.prototype.loadKeyAndSignNonce = function (nonce) {\n  const contents = fs.readFileSync(this.options.userCreds).toString();\n  const re = new RegExp(CREDS.source, 'g');\n  re.exec(contents); // consume jwt\n\n  const m = re.exec(contents); // seed\n\n  if (m === null) {\n    this.emit('error', new NatsError(NO_SEED_IN_CREDS_MSG, NO_SEED_IN_CREDS));\n    this.closeStream();\n    return;\n  }\n\n  const sk = nkeys.fromSeed(Buffer.from(m[1]));\n  return sk.sign(nonce);\n};\n/**\n * Helper that takes a user credentials file and\n * generates the proper opts object with proper handlers\n * filled in. e.g nats.connect(url, nats.creds(\"my_creds.ttx\")\n *\n * @params {String} [filepath]\n *\n * @api public\n */\n\n\nexports.creds = function (filepath) {\n  if (undefined === filepath) {\n    return undefined;\n  }\n\n  return {\n    userCreds: filepath\n  };\n};\n/**\n * Check for Nkey mismatch.\n *\n * @api private\n */\n\n\nClient.prototype.checkNkeyMismatch = function () {\n  if (undefined === this.info.nonce) {\n    return false;\n  } // If this has been specified make sure we can open the file and parse it.\n\n\n  if (this.options.userCreds !== undefined) {\n    // Treat this as a filename.\n    // For now we will not capture an error on file not found etc.\n    const contents = fs.readFileSync(this.options.userCreds).toString();\n\n    if (CREDS.exec(contents) === null) {\n      this.emit('error', new NatsError(BAD_CREDS_MSG, BAD_CREDS));\n      this.closeStream();\n      return true;\n    } // We have a valid file, set up callback handlers.\n\n\n    const client = this;\n\n    this.options.nonceSigner = function (nonce) {\n      return client.loadKeyAndSignNonce(nonce);\n    };\n\n    this.options.userJWT = function () {\n      return client.loadUserJWT();\n    };\n\n    return false;\n  }\n\n  if (undefined === this.options.nonceSigner) {\n    this.emit('error', new NatsError(SIGNATURE_REQUIRED_MSG, SIGNATURE_REQUIRED));\n    this.closeStream();\n    return true;\n  }\n\n  if (typeof this.options.nonceSigner !== 'function') {\n    this.emit('error', new NatsError(SIGCB_NOTFUNC_MSG, SIGCB_NOTFUNC));\n    this.closeStream();\n    return true;\n  }\n\n  if (undefined === this.options.nkey && undefined === this.options.userJWT) {\n    this.emit('error', new NatsError(NKEY_OR_JWT_REQ_MSG, NKEY_OR_JWT_REQ));\n    this.closeStream();\n    return true;\n  }\n\n  return false;\n};\n/**\n * Callback for first flush/connect.\n *\n * @api private\n */\n\n\nClient.prototype.connectCB = function () {\n  const wasReconnecting = this.reconnecting;\n  const event = wasReconnecting === true ? 'reconnect' : 'connect';\n  this.reconnecting = false;\n  this.reconnects = 0;\n  this.wasConnected = true;\n  this.currentServer.didConnect = true;\n  this.emit(event, this);\n  this.flushPending();\n};\n/**\n * @api private\n */\n\n\nClient.prototype.cancelHeartbeat = function () {\n  if (this.pingTimer) {\n    clearTimeout(this.pingTimer);\n    delete this.pingTimer;\n  }\n};\n/**\n * @api private\n */\n\n\nClient.prototype.scheduleHeartbeat = function () {\n  this.pingTimer = setTimeout(function (client) {\n    client.emit('pingtimer');\n\n    if (client.closed) {\n      return;\n    } // we could be waiting on the socket to connect\n\n\n    if (client.stream && !client.stream.connecting) {\n      client.emit('pingcount', client.pout);\n      client.pout++;\n\n      if (client.pout > client.options.maxPingOut) {\n        // processErr will scheduleReconnect\n        client.processErr(STALE_CONNECTION_ERR); // don't reschedule, new connection initiated\n\n        return;\n      } else {\n        // send the ping\n        client.sendCommand(PING_REQUEST);\n\n        if (client.pongs) {\n          // no callback\n          client.pongs.push(undefined);\n        }\n      }\n    } // reschedule\n\n\n    client.scheduleHeartbeat();\n  }, this.options.pingInterval, this);\n};\n/**\n * @api private\n */\n\n\nClient.prototype.clearConnectionTimeoutHandler = function () {\n  if (this.connectionTimeoutHandler) {\n    clearTimeout(this.connectionTimeoutHandler);\n    delete this.connectionTimeoutHandler;\n  }\n};\n/**\n * Properly setup a stream event handlers.\n *\n * @api private\n */\n\n\nClient.prototype.setupHandlers = function () {\n  const stream = this.stream;\n\n  if (undefined === stream) {\n    return;\n  } // tls upgrade will re-bind the handlers here, so if we have a timer we are going to ignore it\n\n\n  if (this.options.timeout && !this.connectionTimeoutHandler) {\n    this.connectionTimeoutHandler = setTimeout(() => {\n      if (this.stream) {\n        // this fires on the current stream\n        this.stream.destroy(new NatsError(CONN_TIMEOUT_MSG, CONN_TIMEOUT));\n      }\n    }, this.options.timeout);\n  }\n\n  stream.on('connect', () => {\n    this.cancelHeartbeat();\n    this.connected = true;\n    this.scheduleHeartbeat();\n  });\n  stream.on('close', () => {\n    const done = this.closed === true || this.options.reconnect === false || this.servers.length === 0; // if connected, it resets everything as partial buffers may have been sent\n    // this will also reset the heartbeats, but not other timers on requests or subscriptions\n\n    const pongs = this.pongs;\n    this.closeStream();\n\n    if (stream.bytesRead > 0) {\n      // if the client will reconnect, re-setup pongs/pending to sending commands\n      if (!done) {\n        this.pongs = [];\n        this.pending = [];\n        this.pSize = 0;\n      } // now we tell them that we bailed\n\n\n      if (pongs) {\n        pongs.forEach(cb => {\n          if (typeof cb === 'function') {\n            try {\n              cb(new NatsError(DISCONNECT_MSG, DISCONNECT_ERR));\n            } catch (_) {// don't fail\n            }\n          }\n        });\n      }\n\n      this.emit('disconnect');\n    }\n\n    if (done) {\n      this.cleanupTimers();\n      this.emit('close');\n    } else {\n      this.scheduleReconnect();\n    }\n  });\n  stream.on('error', exception => {\n    // If we were connected just return, close event will process\n    if (this.wasConnected === true && this.currentServer.didConnect === true) {\n      return;\n    } // if the current server did not connect at all, and we in\n    // general have not connected to any server, remove it from\n    // this list. Unless overridden\n\n\n    if (this.wasConnected === false && this.currentServer.didConnect === false) {\n      // We can override this behavior with waitOnFirstConnect, which will\n      // treat it like a reconnect scenario.\n      if (this.options.waitOnFirstConnect) {\n        // Pretend to move us into a reconnect state.\n        this.currentServer.didConnect = true;\n      } else {\n        this.servers.splice(this.servers.length - 1, 1);\n      }\n    } // Only bubble up error if we never had connected\n    // to the server and we only have one, and close\n\n\n    if (this.wasConnected === false && this.servers.length === 0) {\n      this.emit('error', new NatsError(CONN_ERR_MSG_PREFIX + exception, CONN_ERR, exception));\n      this.close();\n      return;\n    } // continue with reconnect\n\n\n    this.closeStream();\n  });\n  stream.on('data', data => {\n    // If inbound exists, concat them together. We try to avoid this for split\n    // messages, so this should only really happen for a split control line.\n    // Long term answer is hand rolled parser and not regexp.\n    if (this.inbound) {\n      this.inbound = Buffer.concat([this.inbound, data]);\n    } else {\n      this.inbound = data;\n    } // Process the inbound queue.\n\n\n    this.processInbound();\n  });\n};\n/**\n * Send the connect command. This needs to happen after receiving the first\n * INFO message and after TLS is established if necessary.\n *\n * @api private\n */\n\n\nClient.prototype.sendConnect = function () {\n  // Queue the connect command.\n  const cs = {\n    lang: 'node',\n    version: VERSION,\n    verbose: this.options.verbose,\n    pedantic: this.options.pedantic,\n    protocol: 1\n  };\n\n  if (this.info.nonce !== undefined && this.options.nonceSigner !== undefined) {\n    const sig = this.options.nonceSigner(Buffer.from(this.info.nonce));\n    cs.sig = sig.toString('base64');\n  }\n\n  if (this.options.userJWT !== undefined) {\n    if (typeof this.options.userJWT === 'function') {\n      cs.jwt = this.options.userJWT();\n    } else {\n      cs.jwt = this.options.userJWT;\n    }\n  }\n\n  if (this.options.nkey !== undefined) {\n    cs.nkey = this.options.nkey;\n  }\n\n  if (this.user !== undefined) {\n    cs.user = this.user;\n    cs.pass = this.pass;\n  }\n\n  if (this.tokenHandler !== undefined) {\n    let token;\n\n    try {\n      token = this.tokenHandler();\n    } catch (err) {\n      this.emit('error', new NatsError(BAD_AUTHENTICATION_TH_FAILED_MSG_PREFIX + err, BAD_AUTHENTICATION, err));\n    }\n\n    cs.auth_token = token;\n  } else if (this.token !== undefined) {\n    cs.auth_token = this.token;\n  }\n\n  if (this.options.name !== undefined) {\n    cs.name = this.options.name;\n  }\n\n  if (this.options.nkey !== undefined) {\n    cs.nkey = this.options.nkey;\n  }\n\n  if (this.options.noEcho) {\n    cs.echo = false;\n  } // If we enqueued requests before we received INFO from the server, or we\n  // reconnected, there be other data pending, write this immediately instead\n  // of adding it to the queue.\n\n\n  this.stream.write(CONNECT + SPC + JSON.stringify(cs) + CR_LF);\n};\n/**\n * Properly setup a stream connection with proper events.\n *\n * @api private\n */\n\n\nClient.prototype.createConnection = function () {\n  this.pongs = this.pongs || [];\n  this.pending = this.pending || [];\n  this.pSize = this.pSize || 0;\n  this.pstate = AWAITING_CONTROL; // Clear info processing.\n\n  this.info = null;\n  this.infoReceived = false; // See #45 if we have a stream release the listeners otherwise in addition\n  // to the leaking of events, the old events will still fire.\n\n  if (this.stream) {\n    this.stream.removeAllListeners();\n    this.stream.destroy();\n  } // Create the stream\n\n\n  this.stream = net.createConnection(this.url.port, this.url.hostname); // this change makes it a bit faster on Linux, slightly worse on OS X\n\n  this.stream.setNoDelay(true); // Setup the proper handlers.\n\n  this.setupHandlers();\n};\n/**\n * Initialize client state.\n *\n * @api private\n */\n\n\nClient.prototype.initState = function () {\n  this.ssid = 0;\n  this.subs = {};\n  this.reconnects = 0;\n  this.connected = false;\n  this.wasConnected = false;\n  this.reconnecting = false;\n  this.pending = [];\n  this.pout = 0;\n};\n/**\n * Close the connection to the server.\n *\n * @api public\n */\n\n\nClient.prototype.close = function () {\n  this.cleanupTimers();\n  this.closed = true;\n  this.removeAllListeners();\n  this.closeStream();\n  this.ssid = -1;\n  this.subs = null;\n  this.pstate = -1;\n  this.pongs = null;\n  this.pending = null;\n  this.pSize = 0;\n};\n/**\n * Cancels all the timers, ping, subs, requests.\n * Should only be called on a close.\n * @api private\n */\n\n\nClient.prototype.cleanupTimers = function () {\n  this.cancelHeartbeat();\n\n  if (this.respmux && this.respmux.requestMap) {\n    for (const p in this.respmux.requestMap) {\n      if (Object.hasOwnProperty.call(this.respmux.requestMap, p)) {\n        this.cancelMuxRequest(p);\n      }\n    }\n  }\n\n  if (this.subs) {\n    for (const p in this.subs) {\n      if (Object.hasOwnProperty.call(this.subs, p)) {\n        const sub = this.subs[p];\n\n        if (sub.timeout) {\n          clearTimeout(sub.timeout);\n          delete sub.timeout;\n        }\n      }\n    }\n  }\n};\n/**\n * Close down the stream and clear state.\n *\n * @api private\n */\n\n\nClient.prototype.closeStream = function () {\n  if (this.stream !== null) {\n    this.stream.destroy();\n    this.clearConnectionTimeoutHandler();\n    this.stream = null;\n  }\n\n  if (this.connected === true || this.closed === true) {\n    this.pongs = null;\n    this.pout = 0;\n    this.pending = [];\n    this.pSize = 0;\n    this.connected = false;\n  }\n\n  this.inbound = null; // if we are not connected, let's not queue up heartbeats\n\n  this.cancelHeartbeat();\n};\n/**\n * Flush all pending data to the server.\n *\n * @api private\n */\n\n\nClient.prototype.flushPending = function () {\n  if (this.connected === false || this.pending === null || this.pending.length === 0 || this.infoReceived !== true) {\n    return;\n  }\n\n  const write = data => {\n    this.pending = [];\n    this.pSize = 0;\n    return this.stream.write(data);\n  };\n\n  if (!this.pBufs) {\n    // All strings, fastest for now.\n    return write(this.pending.join(EMPTY));\n  } else {\n    // We have some or all Buffers. Figure out if we can optimize.\n    let allBufs = true;\n\n    for (let i = 0; i < this.pending.length; i++) {\n      if (!Buffer.isBuffer(this.pending[i])) {\n        allBufs = false;\n        break;\n      }\n    } // If all buffers, concat together and write once.\n\n\n    if (allBufs) {\n      return write(Buffer.concat(this.pending, this.pSize));\n    } else {\n      // We have a mix, so write each one individually.\n      const pending = this.pending;\n      this.pending = [];\n      this.pSize = 0;\n      let result = true;\n\n      for (let i = 0; i < pending.length; i++) {\n        result = this.stream.write(pending[i]) && result;\n      }\n\n      return result;\n    }\n  }\n};\n/**\n * Strips all SUBS commands from pending during initial connection completed since\n * we send the subscriptions as a separate operation.\n *\n * @api private\n */\n\n\nClient.prototype.stripPendingSubs = function () {\n  const pending = this.pending;\n  this.pending = [];\n  this.pSize = 0;\n\n  for (let i = 0; i < pending.length; i++) {\n    if (!SUBRE.test(pending[i])) {\n      // Re-queue the command.\n      this.sendCommand(pending[i]);\n    }\n  }\n};\n/**\n * Send commands to the server or queue them up if connection pending.\n *\n * @api private\n */\n\n\nClient.prototype.sendCommand = function (cmd) {\n  // Buffer to cut down on system calls, increase throughput.\n  // When receive gets faster, should make this Buffer based..\n  if (this.closed) {\n    return;\n  }\n\n  this.pending.push(cmd);\n\n  if (!Buffer.isBuffer(cmd)) {\n    this.pSize += Buffer.byteLength(cmd);\n  } else {\n    this.pSize += cmd.length;\n    this.pBufs = true;\n  }\n\n  if (this.connected === true) {\n    // First one let's setup flush..\n    if (this.pending.length === 1) {\n      const self = this;\n      setImmediate(function () {\n        self.flushPending();\n      });\n    } else if (this.pSize > FLUSH_THRESHOLD) {\n      // Flush in place when threshold reached..\n      this.flushPending();\n    }\n  }\n};\n/**\n * Sends existing subscriptions to new server after reconnect.\n *\n * @api private\n */\n\n\nClient.prototype.sendSubscriptions = function () {\n  let protos = '';\n\n  for (const sid in this.subs) {\n    if (Object.hasOwnProperty.call(this.subs, sid)) {\n      const sub = this.subs[sid];\n      let proto;\n\n      if (sub.qgroup) {\n        proto = [SUB, sub.subject, sub.qgroup, sid + CR_LF];\n      } else {\n        proto = [SUB, sub.subject, sid + CR_LF];\n      }\n\n      protos += proto.join(SPC);\n\n      if (sub.max) {\n        const max = sub.max - sub.received;\n\n        if (max > 0) {\n          proto = [UNSUB, sid, max + CR_LF];\n        } else {\n          proto = [UNSUB, sid + CR_LF];\n        }\n\n        protos += proto.join(SPC);\n      }\n    }\n  }\n\n  if (protos.length > 0) {\n    this.stream.write(protos);\n  }\n};\n/**\n * Process the inbound data queue.\n *\n * @api private\n */\n\n\nClient.prototype.processInbound = function () {\n  // Hold any regex matches.\n  let m; // For optional yield\n\n  let start;\n\n  if (!this.stream) {\n    // if we are here, the stream was reaped and errors raised\n    // if we continue.\n    return;\n  } // unpause if needed.\n  // FIXME(dlc) client.stream.isPaused() causes 0.10 to fail\n\n\n  this.stream.resume();\n  /* jshint -W083 */\n\n  if (this.options.yieldTime !== undefined) {\n    start = Date.now();\n  }\n\n  while (!this.closed && this.inbound && this.inbound.length > 0) {\n    switch (this.pstate) {\n      case AWAITING_CONTROL:\n        {\n          // Regex only works on strings, so convert once to be more efficient.\n          // Long term answer is a hand rolled parser, not regex.\n          const buf = this.inbound.toString('binary', 0, MAX_CONTROL_LINE_SIZE);\n\n          if ((m = MSG.exec(buf)) !== null) {\n            this.payload = {\n              subj: m[1],\n              sid: parseInt(m[2], 10),\n              reply: m[4],\n              size: parseInt(m[5], 10)\n            };\n            this.payload.psize = this.payload.size + CR_LF_LEN;\n            this.pstate = AWAITING_MSG_PAYLOAD;\n          } else if ((m = OK.exec(buf)) !== null) {// Ignore for now..\n          } else if ((m = ERR.exec(buf)) !== null) {\n            if (this.processErr(m[1])) {\n              return;\n            }\n          } else if ((m = PONG.exec(buf)) !== null) {\n            this.pout = 0;\n            const cb = this.pongs && this.pongs.shift();\n\n            if (cb) {\n              cb();\n            } // FIXME: Should we check for exceptions?\n\n          } else if ((m = PING.exec(buf)) !== null) {\n            this.sendCommand(PONG_RESPONSE);\n          } else if ((m = INFO.exec(buf)) !== null) {\n            this.info = JSON.parse(m[1]); // Always try to read the connect_urls from info\n\n            this.processServerUpdate(); // Process first INFO\n\n            if (this.infoReceived === false) {\n              // Check on TLS mismatch.\n              if (this.checkTLSMismatch() === true) {\n                return;\n              }\n\n              if (this.checkNoEchoMismatch() === true) {\n                return;\n              }\n\n              if (this.checkNkeyMismatch() === true) {\n                return;\n              } // Switch over to TLS as needed.\n\n\n              if (this.info.tls_required === true) {\n                const tlsOpts = {\n                  socket: this.stream\n                };\n\n                if (typeof this.options.tls === 'object') {\n                  for (const key in this.options.tls) {\n                    // noinspection JSUnfilteredForInLoop\n                    tlsOpts[key] = this.options.tls[key];\n                  }\n                } // if we have a stream, this is from an old connection, reap it\n\n\n                if (this.stream) {\n                  this.stream.removeAllListeners();\n                }\n\n                try {\n                  // Refer to issue #310\n                  this.stream = tls.connect(tlsOpts);\n                } catch (error) {\n                  this.emit('error', new NatsError(OPENSSL_ERR_MSG_PREFIX + error, OPENSSL_ERR, error));\n                  return;\n                }\n\n                this.setupHandlers();\n              } // Send the connect message and subscriptions immediately\n\n\n              this.sendConnect(); // add the first callback to a ping\n\n              this.pongs.unshift(err => {\n                if (err) {\n                  // failed the connection\n                  return;\n                } // this gets called when the first pong is received by the connection\n                // if we have a connection timeout timer, remove it\n\n\n                this.clearConnectionTimeoutHandler(); // send any subscriptions, and strip pending\n\n                this.sendSubscriptions();\n                this.stripPendingSubs(); // reset the reconnects for this server\n\n                this.currentServer.reconnects = 0; // invoke the callback\n\n                this.connectCB();\n              }); // send that ping out now\n\n              this.stream.write(PING_REQUEST);\n              this.flushPending(); // Mark as received\n\n              this.infoReceived = true;\n            }\n          } else {\n            // FIXME, check line length for something weird.\n            // Nothing here yet, return\n            return;\n          }\n\n          break;\n        }\n\n      case AWAITING_MSG_PAYLOAD:\n        {\n          // If we do not have the complete message, hold onto the chunks\n          // and assemble when we have all we need. This optimizes for\n          // when we parse a large buffer down to a small number of bytes,\n          // then we receive a large chunk. This avoids a big copy with a\n          // simple concat above.\n          if (this.inbound.length < this.payload.psize) {\n            if (undefined === this.payload.chunks) {\n              this.payload.chunks = [];\n            }\n\n            this.payload.chunks.push(this.inbound);\n            this.payload.psize -= this.inbound.length;\n            this.inbound = null;\n            return;\n          } // If we are here we have the complete message.\n          // Check to see if we have existing chunks\n\n\n          if (this.payload.chunks) {\n            this.payload.chunks.push(this.inbound.slice(0, this.payload.psize)); // don't append trailing control characters\n\n            const mbuf = Buffer.concat(this.payload.chunks, this.payload.size);\n\n            if (this.options.preserveBuffers) {\n              this.payload.msg = mbuf;\n            } else {\n              this.payload.msg = mbuf.toString(this.encoding);\n            }\n          } else {\n            if (this.options.preserveBuffers) {\n              this.payload.msg = this.inbound.slice(0, this.payload.size);\n            } else {\n              this.payload.msg = this.inbound.toString(this.encoding, 0, this.payload.size);\n            }\n          } // Eat the size of the inbound that represents the message.\n\n\n          if (this.inbound.length === this.payload.psize) {\n            this.inbound = null;\n          } else {\n            this.inbound = this.inbound.slice(this.payload.psize);\n          } // process the message\n\n\n          this.processMsg(); // Reset\n\n          this.pstate = AWAITING_CONTROL;\n          this.payload = null; // Check to see if we have an option to yield for other events after yieldTime.\n\n          if (start !== undefined) {\n            if (Date.now() - start > this.options.yieldTime) {\n              this.stream.pause();\n              setImmediate(this.processInbound.bind(this));\n              return;\n            }\n          }\n\n          break;\n        }\n    } // This is applicable for a regex match to eat the bytes we used from a control line.\n\n\n    if (this.inbound && m && !this.closed) {\n      // Chop inbound\n      const psize = m[0].length;\n\n      if (psize >= this.inbound.length) {\n        this.inbound = null;\n      } else {\n        this.inbound = this.inbound.slice(psize);\n      }\n    }\n\n    m = null;\n  }\n};\n/**\n * Process server updates in info object\n * @api internal\n */\n\n\nClient.prototype.processServerUpdate = function () {\n  // noinspection JSUnresolvedVariable\n  if (this.info.connect_urls && this.info.connect_urls.length > 0) {\n    // parse the infos\n    const tmp = {};\n    this.info.connect_urls.forEach(server => {\n      const u = 'nats://' + server;\n      const s = new Server(new url.URL(u)); // implicit servers are ones added via the info connect_urls\n\n      s.implicit = true;\n      tmp[s.url.href] = s;\n    }); // remove implicit servers that are no longer reported\n\n    const toDelete = [];\n    this.servers.forEach((s, index) => {\n      const u = s.url.href;\n\n      if (s.implicit && this.currentServer.url.href !== u && tmp[u] === undefined) {\n        // server was removed\n        toDelete.push(index);\n      } // remove this entry from reported\n\n\n      delete tmp[u];\n    }); // perform the deletion\n\n    toDelete.reverse();\n    toDelete.forEach(index => {\n      this.servers.splice(index, 1);\n    }); // remaining servers are new\n\n    const newURLs = [];\n\n    for (const k in tmp) {\n      if (Object.hasOwnProperty.call(tmp, k)) {\n        this.servers.push(tmp[k]);\n        newURLs.push(k);\n      }\n    }\n\n    if (newURLs.length) {\n      // new reported servers useful for tests\n      this.emit('serversDiscovered', newURLs); // simpler version\n\n      this.emit('servers', newURLs);\n    }\n  }\n};\n/**\n * Process a delivered message and deliver to appropriate subscriber.\n *\n * @api private\n */\n\n\nClient.prototype.processMsg = function () {\n  const sub = this.subs[this.payload.sid];\n\n  if (sub !== undefined) {\n    sub.received += 1; // Check for a timeout, and cancel if received >= expected\n\n    if (sub.timeout) {\n      if (sub.received >= sub.expected) {\n        clearTimeout(sub.timeout);\n        sub.timeout = null;\n      }\n    } // Check for auto-unsubscribe\n\n\n    if (sub.max !== undefined) {\n      if (sub.received === sub.max) {\n        delete this.subs[this.payload.sid];\n        this.emit('unsubscribe', this.payload.sid, sub.subject);\n      } else if (sub.received > sub.max) {\n        this.unsubscribe(this.payload.sid);\n        sub.callback = null;\n      }\n    }\n\n    if (sub.callback) {\n      let msg = this.payload.msg;\n\n      if (this.options.json) {\n        try {\n          if (this.options.preserveBuffers) {\n            msg = JSON.parse(this.payload.msg.toString());\n          } else {\n            msg = JSON.parse(this.payload.msg.toString(this.options.encoding));\n          }\n        } catch (e) {\n          msg = e;\n        }\n      }\n\n      try {\n        sub.callback(msg, this.payload.reply, this.payload.subj, this.payload.sid);\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }\n  }\n};\n/**\n * ProcessErr processes any error messages from the server\n * @returns boolean true if stream was closed\n * @api private\n */\n\n\nClient.prototype.processErr = function (s) {\n  // current NATS clients, will raise an error and close on any errors\n  // except permission errors\n  const m = s ? s.toLowerCase() : '';\n\n  if (m.indexOf(STALE_CONNECTION_ERR) !== -1) {\n    // closeStream() triggers a reconnect if allowed\n    this.closeStream();\n    return true;\n  } else if (m.indexOf(PERMISSIONS_ERR) !== -1) {\n    this.emit('permission_error', new NatsError(s, NATS_PROTOCOL_ERR));\n    return false;\n  } else {\n    this.emit('error', new NatsError(s, NATS_PROTOCOL_ERR));\n    this.closeStream();\n    return true;\n  }\n};\n/**\n * Push a new cluster server.\n *\n * @param {String} uri\n * @api public\n */\n\n\nClient.prototype.addServer = function (uri) {\n  this.servers.push(new Server(new url.URL(uri)));\n\n  if (this.options.noRandomize !== true) {\n    shuffle(this.servers);\n  }\n};\n/**\n * Flush outbound queue to server and call optional callback when server has processed\n * all data.\n *\n * @param {Function} [callback]\n * @api public\n */\n\n\nClient.prototype.flush = function (callback) {\n  if (this.closed) {\n    if (typeof callback === 'function') {\n      callback(new NatsError(CONN_CLOSED_MSG, CONN_CLOSED));\n      return;\n    } else {\n      throw new NatsError(CONN_CLOSED_MSG, CONN_CLOSED);\n    }\n  }\n\n  if (this.pongs) {\n    this.pongs.push(callback);\n    this.sendCommand(PING_REQUEST);\n    this.flushPending();\n  }\n};\n/**\n * Drains all subscriptions. If an opt_callback is provided, the callback\n * is called if there's an error with an error argument.\n *\n * Note that after calling drain, it is impossible to create new subscriptions\n * or any requests. As soon as all messages for the draining subscriptions are\n * processed, it is also impossible to publish new messages.\n *\n * A drained connection is closed when the optional callback is called without arguments.\n * @param callback\n */\n\n\nClient.prototype.drain = function (callback) {\n  if (this.handledClosedOrDraining(callback)) {\n    return;\n  }\n\n  this.draining = true;\n  const subs = [];\n  const drains = [];\n\n  for (const sid in this.subs) {\n    if (Object.hasOwnProperty.call(this.subs, sid)) {\n      const sub = this.subs[sid];\n      sub.sid = sid;\n      subs.push(sub);\n    }\n  }\n\n  subs.forEach(sub => {\n    this.drainSubscription(sub.sid, () => {\n      drains.push(sub);\n\n      if (drains.length === subs.length) {\n        this.noMorePublishing = true;\n        this.flush(() => {\n          this.close();\n\n          if (typeof callback === 'function') {\n            callback();\n          }\n        });\n      }\n    });\n  }); // no subscriptions\n\n  if (subs.length === 0) {\n    this.noMorePublishing = true;\n    this.close();\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n};\n/**\n * Returns true if the client is closed or draining, caller should\n * return as error was generated.\n * @private\n * @param {Function} [callback]\n * @returns {boolean}\n */\n\n\nClient.prototype.handledClosedOrDraining = function (callback) {\n  if (this.closed) {\n    return this.throwOrEmit(new NatsError(CONN_CLOSED_MSG, CONN_CLOSED), callback);\n  }\n\n  if (this.draining) {\n    return this.throwOrEmit(new NatsError(CONN_DRAINING_MSG, CONN_DRAINING), callback);\n  }\n};\n/**\n * Publish a message to the given subject, with optional reply and callback.\n *\n * @param {String} subject\n * @param {String | Buffer | Object} [data]\n * @param {String} [reply]\n * @param {Function} [callback]\n * @api public\n */\n\n\nClient.prototype.publish = function (subject, data, reply, callback) {\n  const args = callbackShifter(4, Array.prototype.slice.call(arguments));\n  subject = args[0];\n  data = args[1];\n  reply = args[2];\n  callback = args[3];\n\n  if (this.noMorePublishing) {\n    return this.throwOrEmit(new NatsError(CONN_DRAINING_MSG, CONN_DRAINING));\n  }\n\n  if (!this.options.json) {\n    data = data || EMPTY;\n  } else {\n    // undefined is not a valid JSON-serializable value, but null is\n    data = data === undefined ? null : data;\n  }\n\n  if (this.handledInvalidArgs({\n    subject,\n    data,\n    reply,\n    callback\n  })) {\n    return;\n  } // Hold PUB SUB [REPLY]\n\n\n  let psub;\n\n  if (reply === undefined) {\n    psub = 'PUB ' + subject + SPC;\n  } else {\n    psub = 'PUB ' + subject + SPC + reply + SPC;\n  } // Need to treat sending buffers different.\n\n\n  if (!Buffer.isBuffer(data)) {\n    let str = data;\n\n    if (this.options.json) {\n      try {\n        str = JSON.stringify(data);\n      } catch (e) {\n        throw new NatsError(BAD_JSON_MSG, BAD_JSON);\n      }\n    }\n\n    this.sendCommand(psub + Buffer.byteLength(str) + CR_LF + str + CR_LF);\n  } else {\n    const b = Buffer.allocUnsafe(psub.length + data.length + 2 * CR_LF_LEN + data.length.toString().length);\n    const len = b.write(psub + data.length + CR_LF);\n    data.copy(b, len);\n    b.write(CR_LF, len + data.length);\n    this.sendCommand(b);\n  }\n\n  if (callback !== undefined) {\n    this.flush(callback);\n  } else if (this.closed) {\n    throw new NatsError(CONN_CLOSED_MSG, CONN_CLOSED);\n  }\n};\n/**\n * @api private\n */\n\n\nClient.prototype.throwOrEmit = function (err, callback) {\n  if (typeof callback === 'function') {\n    callback(err);\n  } else {\n    this.emit('error', err);\n  }\n\n  return true;\n};\n/**\n * @api private\n */\n\n\nClient.prototype.handledInvalidArgs = function (args) {\n  const {\n    subject,\n    reply,\n    data,\n    callback,\n    options,\n    timeout\n  } = args;\n\n  if (!subject) {\n    return this.throwOrEmit(new NatsError(BAD_SUBJECT_MSG, BAD_SUBJECT), callback);\n  }\n\n  if (reply && typeof reply !== 'string') {\n    return this.throwOrEmit(new NatsError(BAD_REPLY_MSG, BAD_REPLY), callback);\n  }\n\n  if (data && typeof data === 'function') {\n    return this.throwOrEmit(new NatsError(BAD_MSG_MSG, BAD_MSG), callback);\n  }\n\n  if (callback && typeof callback !== 'function') {\n    return this.throwOrEmit(new NatsError(BAD_CALLBACK_MSG, BAD_CALLBACK));\n  }\n\n  if (options && typeof options !== 'object') {\n    return this.throwOrEmit(new NatsError(BAD_OPTIONS_MSG, BAD_OPTIONS), callback);\n  }\n\n  if (timeout && typeof timeout !== 'number') {\n    return this.throwOrEmit(new NatsError(BAD_TIMEOUT_MSG, BAD_TIMEOUT), callback);\n  }\n};\n/**\n * Subscribe to a given subject, with optional options and callback. opts can be\n * ommitted, even with a callback. The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {Object} [options]\n * @param {Function} callback - callback arguments are data, reply subject (may be undefined), and subscription id\n * @return {Number}\n * @api public\n */\n\n\nClient.prototype.subscribe = function (subject, options, callback) {\n  const args = callbackShifter(3, Array.prototype.slice.call(arguments));\n  subject = args[0];\n  options = args[1] || {};\n  callback = args[2];\n  const qgroup = options.queue;\n  const max = options.max;\n\n  if (this.handledInvalidArgs({\n    subject,\n    options,\n    callback\n  })) {\n    return 0;\n  }\n\n  if (this.handledClosedOrDraining(callback)) {\n    return 0;\n  }\n\n  this.ssid += 1;\n  this.subs[this.ssid] = {\n    subject: subject,\n    callback: callback,\n    received: 0\n  };\n  let proto;\n\n  if (typeof qgroup === 'string') {\n    this.subs[this.ssid].qgroup = qgroup;\n    proto = [SUB, subject, qgroup, this.ssid + CR_LF];\n  } else {\n    proto = [SUB, subject, this.ssid + CR_LF];\n  }\n\n  this.sendCommand(proto.join(SPC));\n  this.emit('subscribe', this.ssid, subject, options);\n\n  if (max) {\n    this.unsubscribe(this.ssid, max);\n  }\n\n  return this.ssid;\n};\n/**\n * Unsubscribe to a given Subscriber Id, with optional max parameter.\n * Unsubscribing to a subscription that already yielded the specified number of messages\n * will clear any pending timeout callbacks.\n *\n * @param {Number} sid\n * @param {Number} [max]\n * @api public\n */\n\n\nClient.prototype.unsubscribe = function (sid, max) {\n  if (!sid || this.closed) {\n    return;\n  } // in the case of new muxRequest, it is possible they want perform\n  // an unsubscribe with the returned 'sid'. Intercept that and clear\n  // the request configuration. Mux requests are always negative numbers\n\n\n  if (sid < 0) {\n    this.cancelMuxRequest(sid);\n    return;\n  }\n\n  let proto;\n\n  if (max) {\n    proto = [UNSUB, sid, max + CR_LF];\n  } else {\n    proto = [UNSUB, sid + CR_LF];\n  }\n\n  this.sendCommand(proto.join(SPC));\n  const sub = this.subs[sid];\n\n  if (sub === undefined) {\n    return;\n  }\n\n  sub.max = max;\n\n  if (sub.max === undefined || sub.received >= sub.max) {\n    // remove any timeouts that may be pending\n    if (sub.timeout) {\n      clearTimeout(sub.timeout);\n      sub.timeout = null;\n    }\n\n    delete this.subs[sid];\n    this.emit('unsubscribe', sid, sub.subject);\n  }\n};\n/**\n * Draining a subscription is similar to unsubscribe but inbound pending messages are\n * not discarded. When the last in-flight message is processed, the subscription handler\n * is removed.\n * @param {Number} sid\n * @param {Function} [callback]\n */\n\n\nClient.prototype.drainSubscription = function (sid, callback) {\n  if (this.handledClosedOrDraining(callback)) {\n    return;\n  }\n\n  const sub = this.subs[sid];\n\n  if (sub === undefined) {\n    if (typeof callback === 'function') {\n      callback();\n    }\n\n    return;\n  }\n\n  if (sub.draining) {\n    if (typeof callback === 'function') {\n      callback(new NatsError(SUB_DRAINING_MSG, SUB_DRAINING));\n    } else {\n      throw new NatsError(SUB_DRAINING_MSG, SUB_DRAINING);\n    }\n\n    return;\n  }\n\n  sub.draining = true;\n  const proto = [UNSUB, sid + CR_LF];\n  this.sendCommand(proto.join(SPC));\n  this.flush(() => {\n    if (sub.timeout) {\n      clearTimeout(sub.timeout);\n      sub.timeout = null;\n    }\n\n    delete this.subs[sid];\n    this.emit('unsubscribe', sid, sub.subject);\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  });\n};\n/**\n * Set a timeout on a subscription. The subscription is cancelled if the\n * expected number of messages is reached or the timeout is reached.\n * If this function is called with an SID from a multiplexed\n * request call, the original timeout handler associated with the multiplexed\n * request is replaced with the one provided to this function.\n *\n * @param {Number} sid\n * @param {Number} timeout\n * @param {Number} expected\n * @param {Function} callback\n * @api public\n */\n\n\nClient.prototype.timeout = function (sid, timeout, expected, callback) {\n  if (!sid) {\n    return;\n  }\n\n  let sub; // check the sid is not a mux sid - which is always negative\n\n  if (sid < 0) {\n    const conf = this.getMuxRequestConfig(sid);\n\n    if (conf && conf.timeout) {\n      // clear auto-set timeout\n      clearTimeout(conf.timeout);\n    }\n\n    sub = conf;\n  } else {\n    sub = this.subs[sid];\n  }\n\n  if (sub) {\n    sub.expected = expected;\n    sub.timeout = setTimeout(() => {\n      callback(sid); // if callback fails unsubscribe will leak\n\n      this.unsubscribe(sid);\n    }, timeout);\n  }\n};\n/**\n * Publish a message with an implicit inbox listener as the reply. Message is optional.\n * This should be treated as a subscription. You can optionally indicate how many\n * messages you only want to receive using opt_options = {max:N}. Otherwise you\n * will need to unsubscribe to stop the message stream.\n *\n * You can also optionally specify the number of milliseconds to wait for the messages\n * to receive using opt_options = {timeout: N}. When the number of messages specified\n * is received before a timeout, the subscription auto-cancels. If the number of messages\n * is not specified, it is the responsibility of the client to unsubscribe to prevent\n * a timeout.\n *\n * The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {String | Object | Buffer} [data]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Number}\n * @api public\n */\n\n\nClient.prototype.request = function (subject, data, options, callback) {\n  if (this.options.useOldRequestStyle) {\n    // noinspection JSDeprecatedSymbols\n    return this.oldRequest(subject, data, options, callback);\n  }\n\n  const args = callbackShifter(4, Array.prototype.slice.call(arguments));\n  subject = args[0];\n  data = args[1];\n  options = args[2] || {};\n  callback = args[3];\n\n  if (this.handledInvalidArgs({\n    subject,\n    data,\n    options,\n    callback\n  })) {\n    return 0;\n  }\n\n  if (this.handledClosedOrDraining(callback)) {\n    return 0;\n  }\n\n  const conf = this.initMuxRequestDetails(callback, options.max);\n  this.publish(subject, data, conf.inbox);\n\n  if (options.timeout) {\n    conf.timeout = setTimeout(() => {\n      if (conf.callback) {\n        conf.callback(new NatsError(REQ_TIMEOUT_MSG_PREFIX + conf.id, REQ_TIMEOUT));\n      }\n\n      this.cancelMuxRequest(conf.token);\n    }, options.timeout);\n  }\n\n  return conf.id;\n};\n/**\n * @deprecated\n * @api private\n */\n\n\nClient.prototype.oldRequest = function (subject, data, options, callback) {\n  const args = callbackShifter(4, Array.prototype.slice.call(arguments));\n  subject = args[0];\n  data = args[1];\n  options = args[2] || {};\n  callback = args[3];\n\n  if (this.handledInvalidArgs({\n    subject,\n    data,\n    options,\n    callback\n  })) {\n    return 0;\n  }\n\n  if (this.handledClosedOrDraining(callback)) {\n    return 0;\n  }\n\n  const inbox = this.createInbox();\n  const s = this.subscribe(inbox, options, function (msg, reply) {\n    callback(msg, reply);\n  });\n  this.publish(subject, data, inbox);\n  return s;\n};\n/**\n * Publish a message with an implicit inbox listener as the reply. Message is optional.\n * This should be treated as a subscription. The subscription is auto-cancelled after the\n * first reply is received or the timeout in millisecond is reached.\n *\n * If a timeout is reached, the callback is invoked with a NatsError with it's code set to\n * `REQ_TIMEOUT` on the first argument of the callback function, and the subscription is\n * cancelled.\n *\n * The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {String | Object | Buffer} [data]\n * @param {Object} [options]\n * @param {Number} timeout\n * @param {Function} callback - can be called with message or NatsError if the request timed out.\n * @return {Number}\n * @api public\n */\n\n\nClient.prototype.requestOne = function (subject, data, options, timeout, callback) {\n  if (this.options.useOldRequestStyle) {\n    // noinspection JSDeprecatedSymbols\n    return this.oldRequestOne(subject, data, options, timeout, callback);\n  }\n\n  const args = callbackShifter(5, Array.prototype.slice.call(arguments));\n  subject = args[0];\n  data = args[1];\n  options = args[2];\n  timeout = args[3];\n  callback = args[4];\n\n  if (timeout === undefined && typeof options === 'number') {\n    timeout = options;\n    options = undefined;\n  }\n\n  if (timeout === undefined && options === undefined && typeof data === 'number') {\n    timeout = data;\n    data = EMPTY;\n  }\n\n  options = options || {};\n  options.max = 1;\n  options.timeout = timeout;\n  return this.request(subject, data, options, callback);\n}; // finds the last index that satisfies the testFn in array a\n\n\nfunction lastIndexOf(a, testFun) {\n  const idx = a.length - 1;\n\n  for (let i = idx; i > -1; i--) {\n    if (testFun(a[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n} // returns an array that shifts the last function in the\n// array to the last element of the array\n\n\nfunction callbackShifter(maxArgs, args) {\n  // last argument is expected to be a function\n  const a = new Array(maxArgs);\n  const idx = lastIndexOf(args, v => typeof v === 'function');\n  const last = args.length - 1;\n\n  if (typeof args[idx] === 'function' && last > idx) {\n    for (let i = idx + 1; i <= last; i++) {\n      if (args[i]) {\n        throw new NatsError('unknown arguments after callback', BAD_CALLBACK);\n      }\n    }\n  } // found a function, at the last index\n\n\n  if (idx !== -1) {\n    a[maxArgs - 1] = args[idx];\n\n    for (let i = 0; i < idx; i++) {\n      a[i] = args[i];\n    }\n  } else {\n    for (let i = 0; i < args.length; i++) {\n      a[i] = args[i];\n    }\n  }\n\n  return a;\n} // exported only for tests\n\n\nexports.callbackShifter = callbackShifter;\n/**\n * Strips the prefix of the request reply to derive the token.\n * This is internal and only used by the new requestOne.\n *\n * @api private\n */\n\nClient.prototype.extractToken = function (subject) {\n  return subject.substr(this.respmux.inboxPrefixLen);\n};\n/**\n * Creates a subscription for the global inbox in the new requestOne.\n * Request tokens, timer, and callbacks are tracked here.\n *\n * @api private\n */\n\n\nClient.prototype.createResponseMux = function () {\n  if (!this.respmux) {\n    const inbox = this.createInbox();\n    const ginbox = inbox + '.*';\n    const sid = this.subscribe(ginbox, (msg, reply, subject) => {\n      const token = this.extractToken(subject);\n      const conf = this.getMuxRequestConfig(token);\n\n      if (conf) {\n        if (conf.callback) {\n          conf.callback(msg, reply);\n        }\n\n        if (Object.hasOwnProperty.call(conf, 'expected')) {\n          conf.received++;\n\n          if (conf.received >= conf.expected) {\n            this.cancelMuxRequest(token);\n            this.emit('unsubscribe', sid, subject);\n          }\n        }\n      }\n    });\n    this.respmux = {};\n    this.respmux.inbox = inbox;\n    this.respmux.inboxPrefixLen = inbox.length + 1;\n    this.respmux.subscriptionID = sid;\n    this.respmux.requestMap = {};\n    this.respmux.nextID = -1;\n  }\n\n  return this.respmux.inbox;\n};\n/**\n * Stores the request callback and other details\n *\n * @api private\n */\n\n\nClient.prototype.initMuxRequestDetails = function (callback, expected) {\n  const ginbox = this.createResponseMux();\n  const token = nuid.next();\n  const inbox = ginbox + '.' + token;\n  const conf = {\n    token: token,\n    callback: callback,\n    inbox: inbox,\n    id: this.respmux.nextID--,\n    received: 0\n  };\n\n  if (expected > 0) {\n    conf.expected = expected;\n  }\n\n  this.respmux.requestMap[token] = conf;\n  return conf;\n};\n/**\n * Returns the mux request configuration\n * @param token\n * @returns Object\n */\n\n\nClient.prototype.getMuxRequestConfig = function (token) {\n  // if the token is a number, we have a fake sid, find the request\n  if (typeof token === 'number') {\n    let entry = null;\n\n    for (const p in this.respmux.requestMap) {\n      if (Object.hasOwnProperty.call(this.respmux.requestMap, p)) {\n        const v = this.respmux.requestMap[p];\n\n        if (v.id === token) {\n          entry = v;\n          break;\n        }\n      }\n    }\n\n    if (entry) {\n      // noinspection JSUnresolvedVariable\n      token = entry.token;\n    }\n  }\n\n  return this.respmux.requestMap[token];\n};\n/**\n * Cancels the mux request\n *\n * @api private\n */\n\n\nClient.prototype.cancelMuxRequest = function (token) {\n  const conf = this.getMuxRequestConfig(token);\n\n  if (conf) {\n    if (conf.timeout) {\n      clearTimeout(conf.timeout);\n    } // the token could be sid, so use the one in the conf\n\n\n    delete this.respmux.requestMap[conf.token];\n  }\n\n  return conf;\n};\n/**\n * @deprecated\n * @api private\n */\n\n\nClient.prototype.oldRequestOne = function (subject, data, options, timeout, callback) {\n  // eslint-disable-next-line prefer-rest-params\n  const args = callbackShifter(5, Array.prototype.slice.call(arguments));\n  subject = args[0];\n  data = args[1];\n  options = args[2];\n  timeout = args[3];\n  callback = args[4];\n\n  if (timeout === undefined && typeof options === 'number') {\n    timeout = options;\n    options = undefined;\n  }\n\n  if (timeout === undefined && options === undefined && typeof data === 'number') {\n    timeout = data;\n    data = EMPTY;\n  }\n\n  options = options || {};\n  options.max = 1;\n  options.timeout = timeout;\n  const sid = this.request(subject, data, options, callback);\n  this.timeout(sid, timeout, 1, function () {\n    callback(new NatsError(REQ_TIMEOUT_MSG_PREFIX + sid, REQ_TIMEOUT));\n  });\n  return sid;\n};\n/**\n * Report number of outstanding subscriptions on this connection.\n *\n * @return {Number}\n * @api public\n */\n\n\nClient.prototype.numSubscriptions = function () {\n  return Object.keys(this.subs).length;\n};\n/**\n * Reconnect to the server.\n *\n * @api private\n */\n\n\nClient.prototype.reconnect = function () {\n  if (this.closed) {\n    return;\n  }\n\n  this.currentServer.reconnects += 1;\n  this.reconnects += 1;\n  this.createConnection();\n\n  if (this.currentServer.didConnect === true) {\n    this.emit('reconnecting');\n  }\n\n  this.currentServer.lastConnect = Date.now();\n};\n/**\n * Setup a timer event to attempt reconnect.\n *\n * @api private\n */\n\n\nClient.prototype.scheduleReconnect = function () {\n  // Just return if no more servers\n  if (this.servers.length === 0) {\n    return;\n  } // Don't set reconnecting state if we are just trying\n  // for the first time.\n\n\n  if (this.wasConnected === true) {\n    this.reconnecting = true;\n  } // Only stall if we have connected before.\n\n\n  let wait = 0;\n\n  if (this.servers[0].didConnect === true) {\n    wait = this.options.reconnectDelayHandler();\n  } // Select a server to connect to - this will be\n  // the first server that meets the wait criteria\n\n\n  const now = Date.now();\n  let maxWait = wait;\n\n  for (let i = 0; i < this.servers.length; i++) {\n    const srv = this.selectServer();\n\n    if (srv.reconnects >= this.options.maxReconnectAttempts && this.options.maxReconnectAttempts !== -1) {\n      // remove the server - we already tried connecting max number of times\n      this.servers.pop();\n      continue;\n    }\n\n    if (srv.lastConnect === undefined) {\n      // never connected here, try it right away\n      this.reconnect();\n      return;\n    }\n\n    if (srv.lastConnect + wait <= now) {\n      // tried before, but after the min wait, try right away\n      this.reconnect();\n      return;\n    } else {\n      // find the smallest amount of time we have to wait to maybe reconnect\n      const m = srv.lastConnect + wait - now;\n\n      if (maxWait > m) {\n        maxWait = m;\n      }\n    }\n  }\n\n  if (this.servers.length === 0) {\n    // we have no more servers\n    this.cleanupTimers();\n    this.emit('close');\n    this.close();\n    return;\n  } // if we are here, we cannot yet reconnect, but can at maxWait\n\n\n  setTimeout(() => {\n    this.scheduleReconnect();\n  }, maxWait);\n};","map":{"version":3,"sources":["/Users/harinarasimhamurthy/workspace/sample-messaging/producer/node_modules/nats/lib/nats.js"],"names":["net","require","tls","util","events","nuid","nkeys","fs","url","VERSION","version","DEFAULT_PORT","DEFAULT_PRE","DEFAULT_URI","MAX_CONTROL_LINE_SIZE","AWAITING_CONTROL","AWAITING_MSG_PAYLOAD","DEFAULT_RECONNECT_TIME_WAIT","DEFAULT_MAX_RECONNECT_ATTEMPTS","DEFAULT_RECONNECT_JITTER","DEFAULT_RECONNECT_JITTER_TLS","DEFAULT_PING_INTERVAL","DEFAULT_MAX_PING_OUT","MSG","OK","ERR","PING","PONG","INFO","SUBRE","CREDS","CR_LF","CR_LF_LEN","length","EMPTY","SPC","SUB","UNSUB","CONNECT","PING_REQUEST","PONG_RESPONSE","BAD_AUTHENTICATION","BAD_CALLBACK","BAD_CREDS","BAD_JSON","BAD_MSG","BAD_OPTIONS","BAD_REPLY","BAD_SUBJECT","BAD_TIMEOUT","CLIENT_CERT_REQ","CONN_CLOSED","CONN_DRAINING","CONN_ERR","CONN_TIMEOUT","DISCONNECT_ERR","INVALID_ENCODING","NATS_PROTOCOL_ERR","NKEY_OR_JWT_REQ","NO_ECHO_NOT_SUPPORTED","NO_SEED_IN_CREDS","NO_USER_JWT_IN_CREDS","NON_SECURE_CONN_REQ","OPENSSL_ERR","PERMISSIONS_ERR","REQ_TIMEOUT","SECURE_CONN_REQ","SIGCB_NOTFUNC","SIGNATURE_REQUIRED","STALE_CONNECTION_ERR","SUB_DRAINING","BAD_AUTHENTICATION_MSG","BAD_AUTHENTICATION_TH_FAILED_MSG_PREFIX","BAD_AUTHENTICATION_TH_NOT_FUNC_MSG","BAD_AUTHENTICATION_T_AND_TH_MSG","BAD_CALLBACK_MSG","BAD_CREDS_MSG","BAD_JSON_MSG","BAD_MSG_MSG","BAD_OPTIONS_MSG","BAD_REPLY_MSG","BAD_SUBJECT_MSG","BAD_TIMEOUT_MSG","CLIENT_CERT_REQ_MSG","CONN_CLOSED_MSG","CONN_DRAINING_MSG","CONN_ERR_MSG_PREFIX","CONN_TIMEOUT_MSG","DISCONNECT_MSG","INVALID_ENCODING_MSG_PREFIX","NKEY_OR_JWT_REQ_MSG","NON_SECURE_CONN_REQ_MSG","NO_ECHO_NOT_SUPPORTED_MSG","NO_SEED_IN_CREDS_MSG","NO_USER_JWT_IN_CREDS_MSG","OPENSSL_ERR_MSG_PREFIX","REQ_TIMEOUT_MSG_PREFIX","SECURE_CONN_REQ_MSG","SIGCB_NOTFUNC_MSG","SIGNATURE_REQUIRED_MSG","SUB_DRAINING_MSG","FLUSH_THRESHOLD","NatsError","message","code","chainedError","Error","captureStackTrace","constructor","name","inherits","exports","createInbox","next","Client","opts","EventEmitter","call","parseOptions","initState","selectServer","createConnection","connect","undefined","sanitizeUrl","prototype","assignOption","prop","assign","options","shuffle","array","i","j","Math","floor","random","temp","encoding","maxPingOut","maxReconnectAttempts","noEcho","pedantic","pingInterval","reconnect","reconnectTimeWait","reconnectJitter","reconnectJitterTLS","useOldRequestStyle","verbose","waitOnFirstConnect","port","user","pass","token","tokenHandler","reconnectDelayHandler","jitter","Buffer","isEncoding","servers","Array","isArray","forEach","server","push","Server","URL","noRandomize","indexOf","unshift","protocol","timeout","extra","host","exec","u","didConnect","reconnects","lastConnect","toString","href","shift","currentServer","un","username","pw","password","up","auth","split","checkNoEchoMismatch","info","proto","emit","closeStream","checkTLSMismatch","tls_required","stream","encrypted","tls_verify","cert","loadUserJWT","contents","readFileSync","userCreds","m","loadKeyAndSignNonce","nonce","re","RegExp","source","sk","fromSeed","from","sign","creds","filepath","checkNkeyMismatch","client","nonceSigner","userJWT","nkey","connectCB","wasReconnecting","reconnecting","event","wasConnected","flushPending","cancelHeartbeat","pingTimer","clearTimeout","scheduleHeartbeat","setTimeout","closed","connecting","pout","processErr","sendCommand","pongs","clearConnectionTimeoutHandler","connectionTimeoutHandler","setupHandlers","destroy","on","connected","done","bytesRead","pending","pSize","cb","_","cleanupTimers","scheduleReconnect","exception","splice","close","data","inbound","concat","processInbound","sendConnect","cs","lang","sig","jwt","err","auth_token","echo","write","JSON","stringify","pstate","infoReceived","removeAllListeners","hostname","setNoDelay","ssid","subs","respmux","requestMap","p","Object","hasOwnProperty","cancelMuxRequest","sub","pBufs","join","allBufs","isBuffer","result","stripPendingSubs","test","cmd","byteLength","self","setImmediate","sendSubscriptions","protos","sid","qgroup","subject","max","received","start","resume","yieldTime","Date","now","buf","payload","subj","parseInt","reply","size","psize","parse","processServerUpdate","tlsOpts","socket","key","error","chunks","slice","mbuf","preserveBuffers","msg","processMsg","pause","bind","connect_urls","tmp","s","implicit","toDelete","index","reverse","newURLs","k","expected","unsubscribe","callback","json","e","toLowerCase","addServer","uri","flush","drain","handledClosedOrDraining","draining","drains","drainSubscription","noMorePublishing","throwOrEmit","publish","args","callbackShifter","arguments","handledInvalidArgs","psub","str","b","allocUnsafe","len","copy","subscribe","queue","conf","getMuxRequestConfig","request","oldRequest","initMuxRequestDetails","inbox","id","requestOne","oldRequestOne","lastIndexOf","a","testFun","idx","maxArgs","v","last","extractToken","substr","inboxPrefixLen","createResponseMux","ginbox","subscriptionID","nextID","entry","numSubscriptions","keys","wait","maxWait","srv","pop"],"mappings":"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","sourcesContent":["/*\n * Copyright 2013-2020 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint no-sync: 0 */\n\n'use strict'\n\n/**\n * Module Dependencies\n */\nconst net = require('net')\nconst tls = require('tls')\nconst util = require('util')\nconst events = require('events')\nconst nuid = require('nuid')\nconst nkeys = require('ts-nkeys')\nconst fs = require('fs')\nconst url = require('url')\n\n/**\n * Constants\n */\nconst VERSION = require('../package.json').version\n\nconst DEFAULT_PORT = 4222\nconst DEFAULT_PRE = 'nats://localhost:'\nconst DEFAULT_URI = DEFAULT_PRE + DEFAULT_PORT\n\nconst MAX_CONTROL_LINE_SIZE = 4096\n\n// Parser state\nconst AWAITING_CONTROL = 0\nconst AWAITING_MSG_PAYLOAD = 1\n\n// Reconnect Parameters, 2 sec wait, 10 tries\nconst DEFAULT_RECONNECT_TIME_WAIT = 2 * 1000\nconst DEFAULT_MAX_RECONNECT_ATTEMPTS = 10\nconst DEFAULT_RECONNECT_JITTER = 100\nconst DEFAULT_RECONNECT_JITTER_TLS = 1000\n\n// Ping interval\nconst DEFAULT_PING_INTERVAL = 2 * 60 * 1000 // 2 minutes\nconst DEFAULT_MAX_PING_OUT = 2\n\n// Protocol\nconst MSG = /^MSG\\s+([^\\s\\r\\n]+)\\s+([^\\s\\r\\n]+)\\s+(([^\\s\\r\\n]+)[^\\S\\r\\n]+)?(\\d+)\\r\\n/i\nconst OK = /^\\+OK\\s*\\r\\n/i\nconst ERR = /^-ERR\\s+('.+')?\\r\\n/i\nconst PING = /^PING\\r\\n/i\nconst PONG = /^PONG\\r\\n/i\nconst INFO = /^INFO\\s+([^\\r\\n]+)\\r\\n/i\nconst SUBRE = /^SUB\\s+([^\\r\\n]+)\\r\\n/i\nconst CREDS = /\\s*(?:(?:[-]{3,}[^\\n]*[-]{3,}\\n)(.+)(?:\\n\\s*[-]{3,}[^\\n]*[-]{3,}\\n))/i\n\nconst CR_LF = '\\r\\n'\nconst CR_LF_LEN = CR_LF.length\nconst EMPTY = ''\nconst SPC = ' '\n\n// Protocol\nconst SUB = 'SUB'\nconst UNSUB = 'UNSUB'\nconst CONNECT = 'CONNECT'\n\n// Responses\nconst PING_REQUEST = 'PING' + CR_LF\nconst PONG_RESPONSE = 'PONG' + CR_LF\n\n// Errors\nconst BAD_AUTHENTICATION = 'BAD_AUTHENTICATION'\nconst BAD_CALLBACK = 'BAD_CALLBACK'\nconst BAD_CREDS = 'BAD_CREDENTIALS'\nconst BAD_JSON = 'BAD_JSON'\nconst BAD_MSG = 'BAD_MSG'\nconst BAD_OPTIONS = 'BAD_OPTIONS'\nconst BAD_REPLY = 'BAD_REPLY'\nconst BAD_SUBJECT = 'BAD_SUBJECT'\nconst BAD_TIMEOUT = 'BAD_TIMEOUT'\nconst CLIENT_CERT_REQ = 'CLIENT_CERT_REQ'\nconst CONN_CLOSED = 'CONN_CLOSED'\nconst CONN_DRAINING = 'CONN_DRAINING'\nconst CONN_ERR = 'CONN_ERR'\nconst CONN_TIMEOUT = 'CONN_TIMEOUT'\nconst DISCONNECT_ERR = 'DISCONNECT'\nconst INVALID_ENCODING = 'INVALID_ENCODING'\nconst NATS_PROTOCOL_ERR = 'NATS_PROTOCOL_ERR'\nconst NKEY_OR_JWT_REQ = 'NKEY_OR_JWT_REQ'\nconst NO_ECHO_NOT_SUPPORTED = 'NO_ECHO_NOT_SUPPORTED'\nconst NO_SEED_IN_CREDS = 'NO_SEED_IN_CREDS'\nconst NO_USER_JWT_IN_CREDS = 'NO_USER_JWT_IN_CREDS'\nconst NON_SECURE_CONN_REQ = 'NON_SECURE_CONN_REQ'\nconst OPENSSL_ERR = 'OPENSSL_ERR'\nconst PERMISSIONS_ERR = 'permissions violation'\nconst REQ_TIMEOUT = 'REQ_TIMEOUT'\nconst SECURE_CONN_REQ = 'SECURE_CONN_REQ'\nconst SIGCB_NOTFUNC = 'SIG_NOT_FUNC'\nconst SIGNATURE_REQUIRED = 'SIG_REQ'\nconst STALE_CONNECTION_ERR = 'stale connection'\nconst SUB_DRAINING = 'SUB_DRAINING'\n\nconst BAD_AUTHENTICATION_MSG = 'User and Token can not both be provided'\nconst BAD_AUTHENTICATION_TH_FAILED_MSG_PREFIX = 'tokenHandler call failed: '\nconst BAD_AUTHENTICATION_TH_NOT_FUNC_MSG = 'tokenHandler must be a function returning a token'\nconst BAD_AUTHENTICATION_T_AND_TH_MSG = 'token and tokenHandler cannot both be provided'\nconst BAD_CALLBACK_MSG = 'Bad callback'\nconst BAD_CREDS_MSG = 'Bad user credentials'\nconst BAD_JSON_MSG = 'Message should be a non-circular JSON-serializable value'\nconst BAD_MSG_MSG = 'Message can\\'t be a function'\nconst BAD_OPTIONS_MSG = 'Options should be an object.'\nconst BAD_REPLY_MSG = 'Reply can\\'t be a function'\nconst BAD_SUBJECT_MSG = 'Subject must be supplied'\nconst BAD_TIMEOUT_MSG = 'Timeout should be a number'\nconst CLIENT_CERT_REQ_MSG = 'Server requires a client certificate.'\nconst CONN_CLOSED_MSG = 'Connection closed'\nconst CONN_DRAINING_MSG = 'Connection draining'\nconst CONN_ERR_MSG_PREFIX = 'Could not connect to server: '\nconst CONN_TIMEOUT_MSG = 'Connection timeout'\nconst DISCONNECT_MSG = 'Client disconnected, flush was reset'\nconst INVALID_ENCODING_MSG_PREFIX = 'Invalid Encoding:'\nconst NKEY_OR_JWT_REQ_MSG = 'An Nkey or User JWT callback needs to be defined.'\nconst NON_SECURE_CONN_REQ_MSG = 'Server does not support a secure connection.'\nconst NO_ECHO_NOT_SUPPORTED_MSG = 'echo is not supported'\nconst NO_SEED_IN_CREDS_MSG = 'Can not locate signing key in credentials'\nconst NO_USER_JWT_IN_CREDS_MSG = 'Can not locate user jwt in credentials.'\nconst OPENSSL_ERR_MSG_PREFIX = 'TLS credentials verification failed: '\nconst REQ_TIMEOUT_MSG_PREFIX = 'The request timed out for subscription id: '\nconst SECURE_CONN_REQ_MSG = 'Server requires a secure connection.'\nconst SIGCB_NOTFUNC_MSG = 'Signature callback is not a function.'\nconst SIGNATURE_REQUIRED_MSG = 'Server requires an Nkey signature.'\nconst SUB_DRAINING_MSG = 'Subscription draining'\n\nconst FLUSH_THRESHOLD = 65536\n\n/**\n * @param {String} message\n * @param {String} code\n * @param {Error} [chainedError]\n * @constructor\n *\n * @api private\n */\nfunction NatsError (message, code, chainedError) {\n  Error.captureStackTrace(this, this.constructor)\n  this.name = this.constructor.name\n  this.message = message\n  this.code = code\n  // noinspection JSUnusedGlobalSymbols\n  this.chainedError = chainedError\n}\n\nutil.inherits(NatsError, Error)\nexports.NatsError = NatsError\n\n/**\n * Library Version\n */\nexports.version = VERSION\n\n/**\n * Error codes\n */\nexports.BAD_AUTHENTICATION = BAD_AUTHENTICATION\nexports.BAD_CALLBACK = BAD_CALLBACK\nexports.BAD_CREDS = BAD_CREDS\nexports.BAD_JSON = BAD_JSON\nexports.BAD_MSG = BAD_MSG\nexports.BAD_OPTIONS = BAD_OPTIONS\nexports.BAD_REPLY = BAD_REPLY\nexports.BAD_SUBJECT = BAD_SUBJECT\nexports.BAD_TIMEOUT = BAD_TIMEOUT\nexports.CLIENT_CERT_REQ = CLIENT_CERT_REQ\nexports.CONN_CLOSED = CONN_CLOSED\nexports.CONN_DRAINING = CONN_DRAINING\nexports.CONN_ERR = CONN_ERR\nexports.CONN_TIMEOUT = CONN_TIMEOUT\nexports.INVALID_ENCODING = INVALID_ENCODING\nexports.NATS_PROTOCOL_ERR = NATS_PROTOCOL_ERR\nexports.NKEY_OR_JWT_REQ = NKEY_OR_JWT_REQ\nexports.NON_SECURE_CONN_REQ = NON_SECURE_CONN_REQ\nexports.NO_ECHO_NOT_SUPPORTED = NO_ECHO_NOT_SUPPORTED\nexports.NO_SEED_IN_CREDS = NO_SEED_IN_CREDS\nexports.NO_USER_JWT_IN_CREDS = NO_USER_JWT_IN_CREDS\nexports.OPENSSL_ERR = OPENSSL_ERR\nexports.PERMISSIONS_ERR = PERMISSIONS_ERR\nexports.REQ_TIMEOUT = REQ_TIMEOUT\nexports.SECURE_CONN_REQ = SECURE_CONN_REQ\nexports.SIGCB_NOTFUNC = SIGCB_NOTFUNC\nexports.SIGNATURE_REQUIRED = SIGNATURE_REQUIRED\nexports.STALE_CONNECTION_ERR = STALE_CONNECTION_ERR\nexports.SUB_DRAINING = SUB_DRAINING\n\n/**\n * Create a properly formatted inbox subject.\n *\n * @api public\n */\nconst createInbox = exports.createInbox = function () {\n  return ('_INBOX.' + nuid.next())\n}\n\n/**\n * Initialize a client with the appropriate options.\n *\n * @param {Object} [opts]\n * @api public\n */\nfunction Client (opts) {\n  events.EventEmitter.call(this)\n  this.parseOptions(opts)\n  this.initState()\n  // Select a server to connect to.\n  this.selectServer()\n  this.createConnection()\n}\n\n/**\n * Connect to a nats-server and return the client.\n * Argument can be a url, or an object with a 'url'\n * property and additional options.\n *\n * @params {Mixed} [url] - Url, port, or options object\n * @params {Object} [opts] - Options\n * @api public\n */\nexports.connect = function (url, opts) {\n  // If we receive one parameter, parser will\n  // figure out intent. If we provided opts, then\n  // first parameter should be url, and second an\n  // options object.\n  if (opts !== undefined) {\n    if (typeof opts !== 'object') {\n      throw new NatsError(BAD_OPTIONS_MSG, BAD_OPTIONS)\n    }\n    opts.url = sanitizeUrl(url)\n  } else {\n    opts = url\n  }\n  return new Client(opts)\n}\n\n/**\n * Connected clients are event emitters.\n */\nutil.inherits(Client, events.EventEmitter)\n\n/**\n * Allow createInbox to be called on a client.\n *\n * @api public\n */\nClient.prototype.createInbox = createInbox\n\nClient.prototype.assignOption = function (opts, prop, assign) {\n  if (assign === undefined) {\n    assign = prop\n  }\n  if (opts[prop] !== undefined) {\n    this.options[assign] = opts[prop]\n  }\n}\n\nfunction shuffle (array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    const temp = array[i]\n    array[i] = array[j]\n    array[j] = temp\n  }\n  return array\n}\n\n/**\n * Parse the constructor/connect options.\n *\n * @param {Object} [opts]\n * @api private\n */\nClient.prototype.parseOptions = function (opts) {\n  const options = this.options = {\n    encoding: 'utf8',\n    maxPingOut: DEFAULT_MAX_PING_OUT,\n    maxReconnectAttempts: DEFAULT_MAX_RECONNECT_ATTEMPTS,\n    noEcho: false,\n    pedantic: false,\n    pingInterval: DEFAULT_PING_INTERVAL,\n    reconnect: true,\n    reconnectTimeWait: DEFAULT_RECONNECT_TIME_WAIT,\n    reconnectJitter: DEFAULT_RECONNECT_JITTER,\n    reconnectJitterTLS: DEFAULT_RECONNECT_JITTER_TLS,\n    tls: false,\n    useOldRequestStyle: false,\n    verbose: false,\n    waitOnFirstConnect: false\n  }\n\n  if (undefined === opts) {\n    options.url = DEFAULT_URI\n  } else if (typeof opts === 'number') {\n    options.url = DEFAULT_PRE + opts\n  } else if (typeof opts === 'string') {\n    options.url = sanitizeUrl(opts)\n  } else if (typeof opts === 'object') {\n    if (opts.port !== undefined) {\n      options.url = DEFAULT_PRE + opts.port\n    }\n    // Pull out various options here\n    this.assignOption(opts, 'timeout')\n    this.assignOption(opts, 'encoding')\n    this.assignOption(opts, 'json')\n    this.assignOption(opts, 'maxPingOut')\n    this.assignOption(opts, 'maxReconnectAttempts')\n    this.assignOption(opts, 'name')\n    this.assignOption(opts, 'nkey')\n    this.assignOption(opts, 'noEcho')\n    this.assignOption(opts, 'noRandomize')\n    this.assignOption(opts, 'nonceSigner')\n    this.assignOption(opts, 'pass')\n    this.assignOption(opts, 'pedantic')\n    this.assignOption(opts, 'pingInterval')\n    this.assignOption(opts, 'preserveBuffers')\n    this.assignOption(opts, 'reconnect')\n    this.assignOption(opts, 'reconnectJitter')\n    this.assignOption(opts, 'reconnectJitterTLS')\n    this.assignOption(opts, 'reconnectDelayHandler')\n    this.assignOption(opts, 'reconnectTimeWait')\n    this.assignOption(opts, 'servers')\n    this.assignOption(opts, 'tls')\n    this.assignOption(opts, 'token')\n    this.assignOption(opts, 'tokenHandler')\n    this.assignOption(opts, 'url')\n    this.assignOption(opts, 'useOldRequestStyle')\n    this.assignOption(opts, 'user')\n    this.assignOption(opts, 'userCreds')\n    this.assignOption(opts, 'userJWT')\n    this.assignOption(opts, 'verbose')\n    this.assignOption(opts, 'waitOnFirstConnect')\n    this.assignOption(opts, 'yieldTime')\n\n    // fixme: aliasing a configuration property name should be an error\n    this.assignOption(opts, 'client', 'name')\n    this.assignOption(opts, 'credentials', 'userCreds')\n    this.assignOption(opts, 'dontRandomize', 'noRandomize')\n    this.assignOption(opts, 'jwt', 'userJWT')\n    this.assignOption(opts, 'JWT', 'userJWT')\n    this.assignOption(opts, 'nkeys', 'nkey')\n    this.assignOption(opts, 'NoRandomize', 'noRandomize')\n    this.assignOption(opts, 'password', 'pass')\n    this.assignOption(opts, 'secure', 'tls')\n    this.assignOption(opts, 'sig', 'nonceSigner')\n    this.assignOption(opts, 'sigCB', 'nonceSigner')\n    this.assignOption(opts, 'sigCallback', 'nonceSigner')\n    this.assignOption(opts, 'sigcb', 'nonceSigner')\n    this.assignOption(opts, 'uri', 'url')\n    this.assignOption(opts, 'urls', 'servers')\n    this.assignOption(opts, 'usercreds', 'userCreds')\n    this.assignOption(opts, 'userjwt', 'userJWT')\n  }\n\n  // Set user/pass as needed if in options.\n  this.user = options.user\n  this.pass = options.pass\n\n  // Set token as needed if in options.\n  this.token = options.token\n  this.tokenHandler = options.tokenHandler\n\n  // Authentication - make sure authentication is valid.\n  if (this.user && this.token) {\n    throw (new NatsError(BAD_AUTHENTICATION_MSG, BAD_AUTHENTICATION))\n  }\n\n  if (this.tokenHandler && typeof this.tokenHandler !== 'function') {\n    throw (new NatsError(BAD_AUTHENTICATION_TH_NOT_FUNC_MSG, BAD_AUTHENTICATION))\n  }\n\n  if (this.tokenHandler && this.token) {\n    throw (new NatsError(BAD_AUTHENTICATION_T_AND_TH_MSG, BAD_AUTHENTICATION))\n  }\n\n  if (options.reconnectDelayHandler && typeof options.reconnectDelayHandler !== 'function') {\n    throw (new NatsError(BAD_OPTIONS, 'reconnectDelayHandler must be a function'))\n  }\n\n  if (!options.reconnectDelayHandler) {\n    options.reconnectDelayHandler = jitter(options)\n  }\n\n  // Encoding - make sure its valid.\n  if (Buffer.isEncoding(options.encoding)) {\n    this.encoding = options.encoding\n  } else {\n    throw new NatsError(INVALID_ENCODING_MSG_PREFIX + options.encoding, INVALID_ENCODING)\n  }\n  // For cluster support\n  this.servers = []\n\n  if (Array.isArray(options.servers)) {\n    options.servers.forEach((server) => {\n      server = sanitizeUrl(server)\n      this.servers.push(new Server(new url.URL(server)))\n    })\n    // Randomize if needed\n    if (options.noRandomize !== true) {\n      shuffle(this.servers)\n    }\n\n    // if they gave an URL we should add it if different\n    if (options.url !== undefined && this.servers.indexOf(options.url) === -1) {\n      // Make url first element so it is attempted first\n      this.servers.unshift(new Server(new url.URL(options.url)))\n    }\n  } else {\n    if (undefined === options.url) {\n      options.url = DEFAULT_URI\n    }\n    this.servers.push(new Server(new url.URL(options.url)))\n  }\n  // If we are not setup for tls, but were handed a url with a tls:// prefix\n  // then upgrade to tls.\n  if (options.tls === false) {\n    this.servers.forEach((server) => {\n      if (server.url.protocol === 'tls' || server.url.protocol === 'tls:') {\n        options.tls = true\n      }\n    })\n  }\n\n  if (options.timeout && typeof options.timeout !== 'number') {\n    throw new NatsError('timeout should be a number', BAD_OPTIONS)\n  }\n}\n\nfunction jitter (options) {\n  return function () {\n    let extra = options.tls ? options.reconnectJitterTLS : options.reconnectJitter\n    if (extra) {\n      extra++\n      extra = Math.floor(Math.random() * extra)\n    }\n    return options.reconnectTimeWait + extra\n  }\n}\n\nfunction sanitizeUrl (host) {\n  if ((/^.*:\\/\\/.*/).exec(host) === null) {\n    // Does not have a scheme.\n    host = 'nats://' + host\n  }\n  const u = new url.URL(host)\n  if (u.port === null || u.port === '') {\n    host += ':' + DEFAULT_PORT\n  }\n  return host\n}\n\n/**\n * Create a new server.\n *\n * @api private\n */\nfunction Server (url) {\n  this.url = url\n  this.didConnect = false\n  this.reconnects = 0\n  this.lastConnect = 0\n}\n\n/**\n * @api private\n */\nServer.prototype.toString = function () {\n  return this.url.href\n}\n\n/**\n * Properly select the next server.\n * We rotate the server list as we go,\n * we also pull auth from urls as needed, or\n * if they were set in options use that as override.\n *\n * @api private\n */\nClient.prototype.selectServer = function () {\n  const server = this.servers.shift()\n\n  // Place in client context.\n  this.currentServer = server\n  this.url = server.url\n  const un = server.url.username || ''\n  const pw = server.url.password || ''\n  let up = ''\n  if (un !== '' && pw !== '') {\n    up = un + ':' + pw\n  } else if (un !== '') {\n    up = un\n  }\n  if (up !== '') {\n    const auth = up.split(':')\n    if (auth.length !== 1) {\n      if (this.options.user === undefined) {\n        this.user = auth[0]\n      }\n      if (this.options.pass === undefined) {\n        this.pass = auth[1]\n      }\n    } else {\n      if (this.options.token === undefined) {\n        this.token = auth[0]\n      }\n    }\n  }\n  this.servers.push(server)\n  return server\n}\n\nClient.prototype.checkNoEchoMismatch = function () {\n  if ((this.info.proto === undefined || this.info.proto < 1) && this.options.noEcho) {\n    this.emit('error', new NatsError(NO_ECHO_NOT_SUPPORTED_MSG, NO_ECHO_NOT_SUPPORTED))\n    this.closeStream()\n    return true\n  }\n  return false\n}\n\n/**\n * Check for TLS configuration mismatch.\n *\n * @api private\n */\nClient.prototype.checkTLSMismatch = function () {\n  // Switch over to TLS as needed on the fly.\n  if (this.info.tls_required === true ||\n    (this.options.tls !== false && this.stream.encrypted !== true)) {\n    if (undefined === this.options.tls || this.options.tls === false) {\n      this.options.tls = true\n    }\n  }\n\n  if (this.info.tls_required === true &&\n    this.options.tls === false) {\n    this.emit('error', new NatsError(SECURE_CONN_REQ_MSG, SECURE_CONN_REQ))\n    this.closeStream()\n    return true\n  }\n\n  if (!this.info.tls_required && this.options.tls !== false) {\n    this.emit('error', new NatsError(NON_SECURE_CONN_REQ_MSG, NON_SECURE_CONN_REQ))\n    this.closeStream()\n    return true\n  }\n\n  if (this.info.tls_verify === true &&\n    this.options.tls.cert === undefined) {\n    this.emit('error', new NatsError(CLIENT_CERT_REQ_MSG, CLIENT_CERT_REQ))\n    this.closeStream()\n    return true\n  }\n  return false\n}\n\n/**\n * Load a user jwt from a chained credential file.\n * @return {String | undefined}\n * @emits NatsError if JWT couldn't be parsed\n * @api private\n */\nClient.prototype.loadUserJWT = function () {\n  const contents = fs.readFileSync(this.options.userCreds).toString()\n  const m = CREDS.exec(contents) // jwt\n  if (m === null) {\n    this.emit('error', new NatsError(NO_USER_JWT_IN_CREDS_MSG, NO_USER_JWT_IN_CREDS))\n    this.closeStream()\n    return\n  }\n  return m[1]\n}\n\n/**\n * Load a user nkey seed from a chained credential file\n * and sign nonce.\n *\n * @api private\n */\nClient.prototype.loadKeyAndSignNonce = function (nonce) {\n  const contents = fs.readFileSync(this.options.userCreds).toString()\n  const re = new RegExp(CREDS.source, 'g')\n  re.exec(contents) // consume jwt\n  const m = re.exec(contents) // seed\n  if (m === null) {\n    this.emit('error', new NatsError(NO_SEED_IN_CREDS_MSG, NO_SEED_IN_CREDS))\n    this.closeStream()\n    return\n  }\n  const sk = nkeys.fromSeed(Buffer.from(m[1]))\n  return sk.sign(nonce)\n}\n\n/**\n * Helper that takes a user credentials file and\n * generates the proper opts object with proper handlers\n * filled in. e.g nats.connect(url, nats.creds(\"my_creds.ttx\")\n *\n * @params {String} [filepath]\n *\n * @api public\n */\nexports.creds = function (filepath) {\n  if (undefined === filepath) {\n    return undefined\n  }\n  return {\n    userCreds: filepath\n  }\n}\n\n/**\n * Check for Nkey mismatch.\n *\n * @api private\n */\nClient.prototype.checkNkeyMismatch = function () {\n  if (undefined === this.info.nonce) {\n    return false\n  }\n\n  // If this has been specified make sure we can open the file and parse it.\n  if (this.options.userCreds !== undefined) {\n    // Treat this as a filename.\n    // For now we will not capture an error on file not found etc.\n    const contents = fs.readFileSync(this.options.userCreds).toString()\n    if (CREDS.exec(contents) === null) {\n      this.emit('error', new NatsError(BAD_CREDS_MSG, BAD_CREDS))\n      this.closeStream()\n      return true\n    }\n    // We have a valid file, set up callback handlers.\n    const client = this\n    this.options.nonceSigner = function (nonce) {\n      return client.loadKeyAndSignNonce(nonce)\n    }\n    this.options.userJWT = function () {\n      return client.loadUserJWT()\n    }\n    return false\n  }\n\n  if (undefined === this.options.nonceSigner) {\n    this.emit('error', new NatsError(SIGNATURE_REQUIRED_MSG, SIGNATURE_REQUIRED))\n    this.closeStream()\n    return true\n  }\n  if (typeof (this.options.nonceSigner) !== 'function') {\n    this.emit('error', new NatsError(SIGCB_NOTFUNC_MSG, SIGCB_NOTFUNC))\n    this.closeStream()\n    return true\n  }\n  if (undefined === this.options.nkey && undefined === this.options.userJWT) {\n    this.emit('error', new NatsError(NKEY_OR_JWT_REQ_MSG, NKEY_OR_JWT_REQ))\n    this.closeStream()\n    return true\n  }\n  return false\n}\n\n/**\n * Callback for first flush/connect.\n *\n * @api private\n */\nClient.prototype.connectCB = function () {\n  const wasReconnecting = this.reconnecting\n  const event = (wasReconnecting === true) ? 'reconnect' : 'connect'\n  this.reconnecting = false\n  this.reconnects = 0\n  this.wasConnected = true\n  this.currentServer.didConnect = true\n\n  this.emit(event, this)\n\n  this.flushPending()\n}\n\n/**\n * @api private\n */\nClient.prototype.cancelHeartbeat = function () {\n  if (this.pingTimer) {\n    clearTimeout(this.pingTimer)\n    delete this.pingTimer\n  }\n}\n\n/**\n * @api private\n */\nClient.prototype.scheduleHeartbeat = function () {\n  this.pingTimer = setTimeout(function (client) {\n    client.emit('pingtimer')\n    if (client.closed) {\n      return\n    }\n    // we could be waiting on the socket to connect\n    if (client.stream && !client.stream.connecting) {\n      client.emit('pingcount', client.pout)\n      client.pout++\n      if (client.pout > client.options.maxPingOut) {\n        // processErr will scheduleReconnect\n        client.processErr(STALE_CONNECTION_ERR)\n        // don't reschedule, new connection initiated\n        return\n      } else {\n        // send the ping\n        client.sendCommand(PING_REQUEST)\n        if (client.pongs) {\n          // no callback\n          client.pongs.push(undefined)\n        }\n      }\n    }\n    // reschedule\n    client.scheduleHeartbeat()\n  }, this.options.pingInterval, this)\n}\n\n/**\n * @api private\n */\nClient.prototype.clearConnectionTimeoutHandler = function () {\n  if (this.connectionTimeoutHandler) {\n    clearTimeout(this.connectionTimeoutHandler)\n    delete this.connectionTimeoutHandler\n  }\n}\n\n/**\n * Properly setup a stream event handlers.\n *\n * @api private\n */\nClient.prototype.setupHandlers = function () {\n  const stream = this.stream\n\n  if (undefined === stream) {\n    return\n  }\n\n  // tls upgrade will re-bind the handlers here, so if we have a timer we are going to ignore it\n  if (this.options.timeout && !this.connectionTimeoutHandler) {\n    this.connectionTimeoutHandler = setTimeout(() => {\n      if (this.stream) {\n        // this fires on the current stream\n        this.stream.destroy(new NatsError(CONN_TIMEOUT_MSG, CONN_TIMEOUT))\n      }\n    }, this.options.timeout)\n  }\n\n  stream.on('connect', () => {\n    this.cancelHeartbeat()\n    this.connected = true\n    this.scheduleHeartbeat()\n  })\n\n  stream.on('close', () => {\n    const done = (this.closed === true || this.options.reconnect === false || this.servers.length === 0)\n    // if connected, it resets everything as partial buffers may have been sent\n    // this will also reset the heartbeats, but not other timers on requests or subscriptions\n    const pongs = this.pongs\n    this.closeStream()\n    if (stream.bytesRead > 0) {\n      // if the client will reconnect, re-setup pongs/pending to sending commands\n      if (!done) {\n        this.pongs = []\n        this.pending = []\n        this.pSize = 0\n      }\n      // now we tell them that we bailed\n      if (pongs) {\n        pongs.forEach((cb) => {\n          if (typeof cb === 'function') {\n            try {\n              cb(new NatsError(DISCONNECT_MSG, DISCONNECT_ERR))\n            } catch (_) {\n              // don't fail\n            }\n          }\n        })\n      }\n      this.emit('disconnect')\n    }\n    if (done) {\n      this.cleanupTimers()\n      this.emit('close')\n    } else {\n      this.scheduleReconnect()\n    }\n  })\n\n  stream.on('error', (exception) => {\n    // If we were connected just return, close event will process\n    if (this.wasConnected === true && this.currentServer.didConnect === true) {\n      return\n    }\n\n    // if the current server did not connect at all, and we in\n    // general have not connected to any server, remove it from\n    // this list. Unless overridden\n    if (this.wasConnected === false && this.currentServer.didConnect === false) {\n      // We can override this behavior with waitOnFirstConnect, which will\n      // treat it like a reconnect scenario.\n      if (this.options.waitOnFirstConnect) {\n        // Pretend to move us into a reconnect state.\n        this.currentServer.didConnect = true\n      } else {\n        this.servers.splice(this.servers.length - 1, 1)\n      }\n    }\n\n    // Only bubble up error if we never had connected\n    // to the server and we only have one, and close\n    if (this.wasConnected === false && this.servers.length === 0) {\n      this.emit('error', new NatsError(CONN_ERR_MSG_PREFIX + exception, CONN_ERR, exception))\n      this.close()\n      return\n    }\n    // continue with reconnect\n    this.closeStream()\n  })\n\n  stream.on('data', (data) => {\n    // If inbound exists, concat them together. We try to avoid this for split\n    // messages, so this should only really happen for a split control line.\n    // Long term answer is hand rolled parser and not regexp.\n    if (this.inbound) {\n      this.inbound = Buffer.concat([this.inbound, data])\n    } else {\n      this.inbound = data\n    }\n\n    // Process the inbound queue.\n    this.processInbound()\n  })\n}\n\n/**\n * Send the connect command. This needs to happen after receiving the first\n * INFO message and after TLS is established if necessary.\n *\n * @api private\n */\nClient.prototype.sendConnect = function () {\n  // Queue the connect command.\n  const cs = {\n    lang: 'node',\n    version: VERSION,\n    verbose: this.options.verbose,\n    pedantic: this.options.pedantic,\n    protocol: 1\n  }\n  if (this.info.nonce !== undefined && this.options.nonceSigner !== undefined) {\n    const sig = this.options.nonceSigner(Buffer.from(this.info.nonce))\n    cs.sig = sig.toString('base64')\n  }\n  if (this.options.userJWT !== undefined) {\n    if (typeof (this.options.userJWT) === 'function') {\n      cs.jwt = this.options.userJWT()\n    } else {\n      cs.jwt = this.options.userJWT\n    }\n  }\n  if (this.options.nkey !== undefined) {\n    cs.nkey = this.options.nkey\n  }\n  if (this.user !== undefined) {\n    cs.user = this.user\n    cs.pass = this.pass\n  }\n  if (this.tokenHandler !== undefined) {\n    let token\n    try {\n      token = this.tokenHandler()\n    } catch (err) {\n      this.emit('error', new NatsError(BAD_AUTHENTICATION_TH_FAILED_MSG_PREFIX + err, BAD_AUTHENTICATION, err))\n    }\n    cs.auth_token = token\n  } else if (this.token !== undefined) {\n    cs.auth_token = this.token\n  }\n  if (this.options.name !== undefined) {\n    cs.name = this.options.name\n  }\n  if (this.options.nkey !== undefined) {\n    cs.nkey = this.options.nkey\n  }\n  if (this.options.noEcho) {\n    cs.echo = false\n  }\n\n  // If we enqueued requests before we received INFO from the server, or we\n  // reconnected, there be other data pending, write this immediately instead\n  // of adding it to the queue.\n  this.stream.write(CONNECT + SPC + JSON.stringify(cs) + CR_LF)\n}\n\n/**\n * Properly setup a stream connection with proper events.\n *\n * @api private\n */\nClient.prototype.createConnection = function () {\n  this.pongs = this.pongs || []\n  this.pending = this.pending || []\n  this.pSize = this.pSize || 0\n  this.pstate = AWAITING_CONTROL\n\n  // Clear info processing.\n  this.info = null\n  this.infoReceived = false\n\n  // See #45 if we have a stream release the listeners otherwise in addition\n  // to the leaking of events, the old events will still fire.\n  if (this.stream) {\n    this.stream.removeAllListeners()\n    this.stream.destroy()\n  }\n  // Create the stream\n  this.stream = net.createConnection(this.url.port, this.url.hostname)\n  // this change makes it a bit faster on Linux, slightly worse on OS X\n  this.stream.setNoDelay(true)\n  // Setup the proper handlers.\n  this.setupHandlers()\n}\n\n/**\n * Initialize client state.\n *\n * @api private\n */\nClient.prototype.initState = function () {\n  this.ssid = 0\n  this.subs = {}\n  this.reconnects = 0\n  this.connected = false\n  this.wasConnected = false\n  this.reconnecting = false\n  this.pending = []\n  this.pout = 0\n}\n\n/**\n * Close the connection to the server.\n *\n * @api public\n */\nClient.prototype.close = function () {\n  this.cleanupTimers()\n  this.closed = true\n  this.removeAllListeners()\n  this.closeStream()\n  this.ssid = -1\n  this.subs = null\n  this.pstate = -1\n  this.pongs = null\n  this.pending = null\n  this.pSize = 0\n}\n\n/**\n * Cancels all the timers, ping, subs, requests.\n * Should only be called on a close.\n * @api private\n */\nClient.prototype.cleanupTimers = function () {\n  this.cancelHeartbeat()\n\n  if (this.respmux && this.respmux.requestMap) {\n    for (const p in this.respmux.requestMap) {\n      if (Object.hasOwnProperty.call(this.respmux.requestMap, p)) {\n        this.cancelMuxRequest(p)\n      }\n    }\n  }\n  if (this.subs) {\n    for (const p in this.subs) {\n      if (Object.hasOwnProperty.call(this.subs, p)) {\n        const sub = this.subs[p]\n        if (sub.timeout) {\n          clearTimeout(sub.timeout)\n          delete sub.timeout\n        }\n      }\n    }\n  }\n}\n\n/**\n * Close down the stream and clear state.\n *\n * @api private\n */\nClient.prototype.closeStream = function () {\n  if (this.stream !== null) {\n    this.stream.destroy()\n    this.clearConnectionTimeoutHandler()\n    this.stream = null\n  }\n  if (this.connected === true || this.closed === true) {\n    this.pongs = null\n    this.pout = 0\n    this.pending = []\n    this.pSize = 0\n    this.connected = false\n  }\n  this.inbound = null\n  // if we are not connected, let's not queue up heartbeats\n  this.cancelHeartbeat()\n}\n\n/**\n * Flush all pending data to the server.\n *\n * @api private\n */\nClient.prototype.flushPending = function () {\n  if (this.connected === false ||\n    this.pending === null ||\n    this.pending.length === 0 ||\n    this.infoReceived !== true) {\n    return\n  }\n\n  const write = (data) => {\n    this.pending = []\n    this.pSize = 0\n    return this.stream.write(data)\n  }\n  if (!this.pBufs) {\n    // All strings, fastest for now.\n    return write(this.pending.join(EMPTY))\n  } else {\n    // We have some or all Buffers. Figure out if we can optimize.\n    let allBufs = true\n    for (let i = 0; i < this.pending.length; i++) {\n      if (!Buffer.isBuffer(this.pending[i])) {\n        allBufs = false\n        break\n      }\n    }\n    // If all buffers, concat together and write once.\n    if (allBufs) {\n      return write(Buffer.concat(this.pending, this.pSize))\n    } else {\n      // We have a mix, so write each one individually.\n      const pending = this.pending\n      this.pending = []\n      this.pSize = 0\n      let result = true\n      for (let i = 0; i < pending.length; i++) {\n        result = this.stream.write(pending[i]) && result\n      }\n      return result\n    }\n  }\n}\n\n/**\n * Strips all SUBS commands from pending during initial connection completed since\n * we send the subscriptions as a separate operation.\n *\n * @api private\n */\nClient.prototype.stripPendingSubs = function () {\n  const pending = this.pending\n  this.pending = []\n  this.pSize = 0\n  for (let i = 0; i < pending.length; i++) {\n    if (!SUBRE.test(pending[i])) {\n      // Re-queue the command.\n      this.sendCommand(pending[i])\n    }\n  }\n}\n\n/**\n * Send commands to the server or queue them up if connection pending.\n *\n * @api private\n */\nClient.prototype.sendCommand = function (cmd) {\n  // Buffer to cut down on system calls, increase throughput.\n  // When receive gets faster, should make this Buffer based..\n\n  if (this.closed) {\n    return\n  }\n\n  this.pending.push(cmd)\n  if (!Buffer.isBuffer(cmd)) {\n    this.pSize += Buffer.byteLength(cmd)\n  } else {\n    this.pSize += cmd.length\n    this.pBufs = true\n  }\n\n  if (this.connected === true) {\n    // First one let's setup flush..\n    if (this.pending.length === 1) {\n      const self = this\n      setImmediate(function () {\n        self.flushPending()\n      })\n    } else if (this.pSize > FLUSH_THRESHOLD) {\n      // Flush in place when threshold reached..\n      this.flushPending()\n    }\n  }\n}\n\n/**\n * Sends existing subscriptions to new server after reconnect.\n *\n * @api private\n */\nClient.prototype.sendSubscriptions = function () {\n  let protos = ''\n  for (const sid in this.subs) {\n    if (Object.hasOwnProperty.call(this.subs, sid)) {\n      const sub = this.subs[sid]\n      let proto\n      if (sub.qgroup) {\n        proto = [SUB, sub.subject, sub.qgroup, sid + CR_LF]\n      } else {\n        proto = [SUB, sub.subject, sid + CR_LF]\n      }\n      protos += proto.join(SPC)\n\n      if (sub.max) {\n        const max = sub.max - sub.received\n        if (max > 0) {\n          proto = [UNSUB, sid, max + CR_LF]\n        } else {\n          proto = [UNSUB, sid + CR_LF]\n        }\n        protos += proto.join(SPC)\n      }\n    }\n  }\n  if (protos.length > 0) {\n    this.stream.write(protos)\n  }\n}\n\n/**\n * Process the inbound data queue.\n *\n * @api private\n */\nClient.prototype.processInbound = function () {\n  // Hold any regex matches.\n  let m\n\n  // For optional yield\n  let start\n\n  if (!this.stream) {\n    // if we are here, the stream was reaped and errors raised\n    // if we continue.\n    return\n  }\n  // unpause if needed.\n  // FIXME(dlc) client.stream.isPaused() causes 0.10 to fail\n  this.stream.resume()\n\n  /* jshint -W083 */\n\n  if (this.options.yieldTime !== undefined) {\n    start = Date.now()\n  }\n\n  while (!this.closed && this.inbound && this.inbound.length > 0) {\n    switch (this.pstate) {\n      case AWAITING_CONTROL: {\n        // Regex only works on strings, so convert once to be more efficient.\n        // Long term answer is a hand rolled parser, not regex.\n        const buf = this.inbound.toString('binary', 0, MAX_CONTROL_LINE_SIZE)\n        if ((m = MSG.exec(buf)) !== null) {\n          this.payload = {\n            subj: m[1],\n            sid: parseInt(m[2], 10),\n            reply: m[4],\n            size: parseInt(m[5], 10)\n          }\n          this.payload.psize = this.payload.size + CR_LF_LEN\n          this.pstate = AWAITING_MSG_PAYLOAD\n        } else if ((m = OK.exec(buf)) !== null) {\n          // Ignore for now..\n        } else if ((m = ERR.exec(buf)) !== null) {\n          if (this.processErr(m[1])) {\n            return\n          }\n        } else if ((m = PONG.exec(buf)) !== null) {\n          this.pout = 0\n          const cb = this.pongs && this.pongs.shift()\n          if (cb) {\n            cb()\n          } // FIXME: Should we check for exceptions?\n        } else if ((m = PING.exec(buf)) !== null) {\n          this.sendCommand(PONG_RESPONSE)\n        } else if ((m = INFO.exec(buf)) !== null) {\n          this.info = JSON.parse(m[1])\n          // Always try to read the connect_urls from info\n          this.processServerUpdate()\n\n          // Process first INFO\n          if (this.infoReceived === false) {\n            // Check on TLS mismatch.\n            if (this.checkTLSMismatch() === true) {\n              return\n            }\n            if (this.checkNoEchoMismatch() === true) {\n              return\n            }\n            if (this.checkNkeyMismatch() === true) {\n              return\n            }\n\n            // Switch over to TLS as needed.\n            if (this.info.tls_required === true) {\n              const tlsOpts = {\n                socket: this.stream\n              }\n              if (typeof this.options.tls === 'object') {\n                for (const key in this.options.tls) {\n                  // noinspection JSUnfilteredForInLoop\n                  tlsOpts[key] = this.options.tls[key]\n                }\n              }\n              // if we have a stream, this is from an old connection, reap it\n              if (this.stream) {\n                this.stream.removeAllListeners()\n              }\n              try {\n                // Refer to issue #310\n                this.stream = tls.connect(tlsOpts)\n              } catch (error) {\n                this.emit('error', new NatsError(OPENSSL_ERR_MSG_PREFIX + error, OPENSSL_ERR, error))\n                return\n              }\n              this.setupHandlers()\n            }\n\n            // Send the connect message and subscriptions immediately\n            this.sendConnect()\n            // add the first callback to a ping\n            this.pongs.unshift((err) => {\n              if (err) {\n                // failed the connection\n                return\n              }\n              // this gets called when the first pong is received by the connection\n              // if we have a connection timeout timer, remove it\n              this.clearConnectionTimeoutHandler()\n              // send any subscriptions, and strip pending\n              this.sendSubscriptions()\n              this.stripPendingSubs()\n              // reset the reconnects for this server\n              this.currentServer.reconnects = 0\n              // invoke the callback\n              this.connectCB()\n            })\n            // send that ping out now\n            this.stream.write(PING_REQUEST)\n            this.flushPending()\n            // Mark as received\n            this.infoReceived = true\n          }\n        } else {\n          // FIXME, check line length for something weird.\n          // Nothing here yet, return\n          return\n        }\n        break\n      }\n\n      case AWAITING_MSG_PAYLOAD: {\n        // If we do not have the complete message, hold onto the chunks\n        // and assemble when we have all we need. This optimizes for\n        // when we parse a large buffer down to a small number of bytes,\n        // then we receive a large chunk. This avoids a big copy with a\n        // simple concat above.\n        if (this.inbound.length < this.payload.psize) {\n          if (undefined === this.payload.chunks) {\n            this.payload.chunks = []\n          }\n          this.payload.chunks.push(this.inbound)\n          this.payload.psize -= this.inbound.length\n          this.inbound = null\n          return\n        }\n\n        // If we are here we have the complete message.\n        // Check to see if we have existing chunks\n        if (this.payload.chunks) {\n          this.payload.chunks.push(this.inbound.slice(0, this.payload.psize))\n          // don't append trailing control characters\n          const mbuf = Buffer.concat(this.payload.chunks, this.payload.size)\n\n          if (this.options.preserveBuffers) {\n            this.payload.msg = mbuf\n          } else {\n            this.payload.msg = mbuf.toString(this.encoding)\n          }\n        } else {\n          if (this.options.preserveBuffers) {\n            this.payload.msg = this.inbound.slice(0, this.payload.size)\n          } else {\n            this.payload.msg = this.inbound.toString(this.encoding, 0, this.payload.size)\n          }\n        }\n\n        // Eat the size of the inbound that represents the message.\n        if (this.inbound.length === this.payload.psize) {\n          this.inbound = null\n        } else {\n          this.inbound = this.inbound.slice(this.payload.psize)\n        }\n\n        // process the message\n        this.processMsg()\n\n        // Reset\n        this.pstate = AWAITING_CONTROL\n        this.payload = null\n\n        // Check to see if we have an option to yield for other events after yieldTime.\n        if (start !== undefined) {\n          if ((Date.now() - start) > this.options.yieldTime) {\n            this.stream.pause()\n            setImmediate(this.processInbound.bind(this))\n            return\n          }\n        }\n        break\n      }\n    }\n\n    // This is applicable for a regex match to eat the bytes we used from a control line.\n    if (this.inbound && m && !this.closed) {\n      // Chop inbound\n      const psize = m[0].length\n      if (psize >= this.inbound.length) {\n        this.inbound = null\n      } else {\n        this.inbound = this.inbound.slice(psize)\n      }\n    }\n    m = null\n  }\n}\n\n/**\n * Process server updates in info object\n * @api internal\n */\nClient.prototype.processServerUpdate = function () {\n  // noinspection JSUnresolvedVariable\n  if (this.info.connect_urls && this.info.connect_urls.length > 0) {\n    // parse the infos\n    const tmp = {}\n    this.info.connect_urls.forEach((server) => {\n      const u = 'nats://' + server\n      const s = new Server(new url.URL(u))\n      // implicit servers are ones added via the info connect_urls\n      s.implicit = true\n      tmp[s.url.href] = s\n    })\n\n    // remove implicit servers that are no longer reported\n    const toDelete = []\n    this.servers.forEach((s, index) => {\n      const u = s.url.href\n      if (s.implicit && this.currentServer.url.href !== u && tmp[u] === undefined) {\n        // server was removed\n        toDelete.push(index)\n      }\n      // remove this entry from reported\n      delete tmp[u]\n    })\n\n    // perform the deletion\n    toDelete.reverse()\n    toDelete.forEach((index) => {\n      this.servers.splice(index, 1)\n    })\n\n    // remaining servers are new\n    const newURLs = []\n    for (const k in tmp) {\n      if (Object.hasOwnProperty.call(tmp, k)) {\n        this.servers.push(tmp[k])\n        newURLs.push(k)\n      }\n    }\n\n    if (newURLs.length) {\n      // new reported servers useful for tests\n      this.emit('serversDiscovered', newURLs)\n      // simpler version\n      this.emit('servers', newURLs)\n    }\n  }\n}\n\n/**\n * Process a delivered message and deliver to appropriate subscriber.\n *\n * @api private\n */\nClient.prototype.processMsg = function () {\n  const sub = this.subs[this.payload.sid]\n  if (sub !== undefined) {\n    sub.received += 1\n    // Check for a timeout, and cancel if received >= expected\n    if (sub.timeout) {\n      if (sub.received >= sub.expected) {\n        clearTimeout(sub.timeout)\n        sub.timeout = null\n      }\n    }\n\n    // Check for auto-unsubscribe\n    if (sub.max !== undefined) {\n      if (sub.received === sub.max) {\n        delete this.subs[this.payload.sid]\n        this.emit('unsubscribe', this.payload.sid, sub.subject)\n      } else if (sub.received > sub.max) {\n        this.unsubscribe(this.payload.sid)\n        sub.callback = null\n      }\n    }\n\n    if (sub.callback) {\n      let msg = this.payload.msg\n      if (this.options.json) {\n        try {\n          if (this.options.preserveBuffers) {\n            msg = JSON.parse(this.payload.msg.toString())\n          } else {\n            msg = JSON.parse(this.payload.msg.toString(this.options.encoding))\n          }\n        } catch (e) {\n          msg = e\n        }\n      }\n      try {\n        sub.callback(msg, this.payload.reply, this.payload.subj, this.payload.sid)\n      } catch (error) {\n        this.emit('error', error)\n      }\n    }\n  }\n}\n\n/**\n * ProcessErr processes any error messages from the server\n * @returns boolean true if stream was closed\n * @api private\n */\nClient.prototype.processErr = function (s) {\n  // current NATS clients, will raise an error and close on any errors\n  // except permission errors\n  const m = s ? s.toLowerCase() : ''\n  if (m.indexOf(STALE_CONNECTION_ERR) !== -1) {\n    // closeStream() triggers a reconnect if allowed\n    this.closeStream()\n    return true\n  } else if (m.indexOf(PERMISSIONS_ERR) !== -1) {\n    this.emit('permission_error', new NatsError(s, NATS_PROTOCOL_ERR))\n    return false\n  } else {\n    this.emit('error', new NatsError(s, NATS_PROTOCOL_ERR))\n    this.closeStream()\n    return true\n  }\n}\n\n/**\n * Push a new cluster server.\n *\n * @param {String} uri\n * @api public\n */\nClient.prototype.addServer = function (uri) {\n  this.servers.push(new Server(new url.URL(uri)))\n\n  if (this.options.noRandomize !== true) {\n    shuffle(this.servers)\n  }\n}\n\n/**\n * Flush outbound queue to server and call optional callback when server has processed\n * all data.\n *\n * @param {Function} [callback]\n * @api public\n */\nClient.prototype.flush = function (callback) {\n  if (this.closed) {\n    if (typeof callback === 'function') {\n      callback(new NatsError(CONN_CLOSED_MSG, CONN_CLOSED))\n      return\n    } else {\n      throw (new NatsError(CONN_CLOSED_MSG, CONN_CLOSED))\n    }\n  }\n  if (this.pongs) {\n    this.pongs.push(callback)\n    this.sendCommand(PING_REQUEST)\n    this.flushPending()\n  }\n}\n\n/**\n * Drains all subscriptions. If an opt_callback is provided, the callback\n * is called if there's an error with an error argument.\n *\n * Note that after calling drain, it is impossible to create new subscriptions\n * or any requests. As soon as all messages for the draining subscriptions are\n * processed, it is also impossible to publish new messages.\n *\n * A drained connection is closed when the optional callback is called without arguments.\n * @param callback\n */\nClient.prototype.drain = function (callback) {\n  if (this.handledClosedOrDraining(callback)) {\n    return\n  }\n  this.draining = true\n  const subs = []\n  const drains = []\n  for (const sid in this.subs) {\n    if (Object.hasOwnProperty.call(this.subs, sid)) {\n      const sub = this.subs[sid]\n      sub.sid = sid\n      subs.push(sub)\n    }\n  }\n\n  subs.forEach((sub) => {\n    this.drainSubscription(sub.sid, () => {\n      drains.push(sub)\n      if (drains.length === subs.length) {\n        this.noMorePublishing = true\n        this.flush(() => {\n          this.close()\n          if (typeof callback === 'function') {\n            callback()\n          }\n        })\n      }\n    })\n  })\n\n  // no subscriptions\n  if (subs.length === 0) {\n    this.noMorePublishing = true\n    this.close()\n    if (typeof callback === 'function') {\n      callback()\n    }\n  }\n}\n\n/**\n * Returns true if the client is closed or draining, caller should\n * return as error was generated.\n * @private\n * @param {Function} [callback]\n * @returns {boolean}\n */\nClient.prototype.handledClosedOrDraining = function (callback) {\n  if (this.closed) {\n    return this.throwOrEmit(new NatsError(CONN_CLOSED_MSG, CONN_CLOSED), callback)\n  }\n  if (this.draining) {\n    return this.throwOrEmit(new NatsError(CONN_DRAINING_MSG, CONN_DRAINING), callback)\n  }\n}\n\n/**\n * Publish a message to the given subject, with optional reply and callback.\n *\n * @param {String} subject\n * @param {String | Buffer | Object} [data]\n * @param {String} [reply]\n * @param {Function} [callback]\n * @api public\n */\nClient.prototype.publish = function (subject, data, reply, callback) {\n  const args = callbackShifter(4, Array.prototype.slice.call(arguments))\n  subject = args[0]\n  data = args[1]\n  reply = args[2]\n  callback = args[3]\n\n  if (this.noMorePublishing) {\n    return this.throwOrEmit(new NatsError(CONN_DRAINING_MSG, CONN_DRAINING))\n  }\n\n  if (!this.options.json) {\n    data = data || EMPTY\n  } else {\n    // undefined is not a valid JSON-serializable value, but null is\n    data = data === undefined ? null : data\n  }\n\n  if (this.handledInvalidArgs({ subject, data, reply, callback })) {\n    return\n  }\n\n  // Hold PUB SUB [REPLY]\n  let psub\n  if (reply === undefined) {\n    psub = 'PUB ' + subject + SPC\n  } else {\n    psub = 'PUB ' + subject + SPC + reply + SPC\n  }\n\n  // Need to treat sending buffers different.\n  if (!Buffer.isBuffer(data)) {\n    let str = data\n    if (this.options.json) {\n      try {\n        str = JSON.stringify(data)\n      } catch (e) {\n        throw (new NatsError(BAD_JSON_MSG, BAD_JSON))\n      }\n    }\n    this.sendCommand(psub + Buffer.byteLength(str) + CR_LF + str + CR_LF)\n  } else {\n    const b = Buffer.allocUnsafe(psub.length + data.length + (2 * CR_LF_LEN) + data.length.toString().length)\n    const len = b.write(psub + data.length + CR_LF)\n    data.copy(b, len)\n    b.write(CR_LF, len + data.length)\n    this.sendCommand(b)\n  }\n\n  if (callback !== undefined) {\n    this.flush(callback)\n  } else if (this.closed) {\n    throw (new NatsError(CONN_CLOSED_MSG, CONN_CLOSED))\n  }\n}\n\n/**\n * @api private\n */\nClient.prototype.throwOrEmit = function (err, callback) {\n  if (typeof callback === 'function') {\n    callback(err)\n  } else {\n    this.emit('error', err)\n  }\n  return true\n}\n\n/**\n * @api private\n */\nClient.prototype.handledInvalidArgs = function (args) {\n  const { subject, reply, data, callback, options, timeout } = args\n  if (!subject) {\n    return this.throwOrEmit(new NatsError(BAD_SUBJECT_MSG, BAD_SUBJECT), callback)\n  }\n  if (reply && typeof reply !== 'string') {\n    return this.throwOrEmit(new NatsError(BAD_REPLY_MSG, BAD_REPLY), callback)\n  }\n  if (data && typeof data === 'function') {\n    return this.throwOrEmit(new NatsError(BAD_MSG_MSG, BAD_MSG), callback)\n  }\n  if (callback && typeof callback !== 'function') {\n    return this.throwOrEmit(new NatsError(BAD_CALLBACK_MSG, BAD_CALLBACK))\n  }\n  if (options && typeof options !== 'object') {\n    return this.throwOrEmit(new NatsError(BAD_OPTIONS_MSG, BAD_OPTIONS), callback)\n  }\n  if (timeout && typeof timeout !== 'number') {\n    return this.throwOrEmit(new NatsError(BAD_TIMEOUT_MSG, BAD_TIMEOUT), callback)\n  }\n}\n\n/**\n * Subscribe to a given subject, with optional options and callback. opts can be\n * ommitted, even with a callback. The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {Object} [options]\n * @param {Function} callback - callback arguments are data, reply subject (may be undefined), and subscription id\n * @return {Number}\n * @api public\n */\nClient.prototype.subscribe = function (subject, options, callback) {\n  const args = callbackShifter(3, Array.prototype.slice.call(arguments))\n  subject = args[0]\n  options = args[1] || {}\n  callback = args[2]\n\n  const qgroup = options.queue\n  const max = options.max\n\n  if (this.handledInvalidArgs({ subject, options, callback })) {\n    return 0\n  }\n\n  if (this.handledClosedOrDraining(callback)) {\n    return 0\n  }\n\n  this.ssid += 1\n  this.subs[this.ssid] = {\n    subject: subject,\n    callback: callback,\n    received: 0\n  }\n\n  let proto\n  if (typeof qgroup === 'string') {\n    this.subs[this.ssid].qgroup = qgroup\n    proto = [SUB, subject, qgroup, this.ssid + CR_LF]\n  } else {\n    proto = [SUB, subject, this.ssid + CR_LF]\n  }\n\n  this.sendCommand(proto.join(SPC))\n  this.emit('subscribe', this.ssid, subject, options)\n\n  if (max) {\n    this.unsubscribe(this.ssid, max)\n  }\n  return this.ssid\n}\n\n/**\n * Unsubscribe to a given Subscriber Id, with optional max parameter.\n * Unsubscribing to a subscription that already yielded the specified number of messages\n * will clear any pending timeout callbacks.\n *\n * @param {Number} sid\n * @param {Number} [max]\n * @api public\n */\nClient.prototype.unsubscribe = function (sid, max) {\n  if (!sid || this.closed) {\n    return\n  }\n\n  // in the case of new muxRequest, it is possible they want perform\n  // an unsubscribe with the returned 'sid'. Intercept that and clear\n  // the request configuration. Mux requests are always negative numbers\n  if (sid < 0) {\n    this.cancelMuxRequest(sid)\n    return\n  }\n\n  let proto\n  if (max) {\n    proto = [UNSUB, sid, max + CR_LF]\n  } else {\n    proto = [UNSUB, sid + CR_LF]\n  }\n  this.sendCommand(proto.join(SPC))\n\n  const sub = this.subs[sid]\n  if (sub === undefined) {\n    return\n  }\n  sub.max = max\n  if (sub.max === undefined || (sub.received >= sub.max)) {\n    // remove any timeouts that may be pending\n    if (sub.timeout) {\n      clearTimeout(sub.timeout)\n      sub.timeout = null\n    }\n    delete this.subs[sid]\n    this.emit('unsubscribe', sid, sub.subject)\n  }\n}\n\n/**\n * Draining a subscription is similar to unsubscribe but inbound pending messages are\n * not discarded. When the last in-flight message is processed, the subscription handler\n * is removed.\n * @param {Number} sid\n * @param {Function} [callback]\n */\nClient.prototype.drainSubscription = function (sid, callback) {\n  if (this.handledClosedOrDraining(callback)) {\n    return\n  }\n\n  const sub = this.subs[sid]\n  if (sub === undefined) {\n    if (typeof callback === 'function') {\n      callback()\n    }\n    return\n  }\n  if (sub.draining) {\n    if (typeof callback === 'function') {\n      callback(new NatsError(SUB_DRAINING_MSG, SUB_DRAINING))\n    } else {\n      throw (new NatsError(SUB_DRAINING_MSG, SUB_DRAINING))\n    }\n    return\n  }\n  sub.draining = true\n  const proto = [UNSUB, sid + CR_LF]\n  this.sendCommand(proto.join(SPC))\n  this.flush(() => {\n    if (sub.timeout) {\n      clearTimeout(sub.timeout)\n      sub.timeout = null\n    }\n    delete this.subs[sid]\n    this.emit('unsubscribe', sid, sub.subject)\n    if (typeof callback === 'function') {\n      callback()\n    }\n  })\n}\n\n/**\n * Set a timeout on a subscription. The subscription is cancelled if the\n * expected number of messages is reached or the timeout is reached.\n * If this function is called with an SID from a multiplexed\n * request call, the original timeout handler associated with the multiplexed\n * request is replaced with the one provided to this function.\n *\n * @param {Number} sid\n * @param {Number} timeout\n * @param {Number} expected\n * @param {Function} callback\n * @api public\n */\nClient.prototype.timeout = function (sid, timeout, expected, callback) {\n  if (!sid) {\n    return\n  }\n  let sub\n  // check the sid is not a mux sid - which is always negative\n  if (sid < 0) {\n    const conf = this.getMuxRequestConfig(sid)\n    if (conf && conf.timeout) {\n      // clear auto-set timeout\n      clearTimeout(conf.timeout)\n    }\n    sub = conf\n  } else {\n    sub = this.subs[sid]\n  }\n\n  if (sub) {\n    sub.expected = expected\n    sub.timeout = setTimeout(() => {\n      callback(sid)\n      // if callback fails unsubscribe will leak\n      this.unsubscribe(sid)\n    }, timeout)\n  }\n}\n\n/**\n * Publish a message with an implicit inbox listener as the reply. Message is optional.\n * This should be treated as a subscription. You can optionally indicate how many\n * messages you only want to receive using opt_options = {max:N}. Otherwise you\n * will need to unsubscribe to stop the message stream.\n *\n * You can also optionally specify the number of milliseconds to wait for the messages\n * to receive using opt_options = {timeout: N}. When the number of messages specified\n * is received before a timeout, the subscription auto-cancels. If the number of messages\n * is not specified, it is the responsibility of the client to unsubscribe to prevent\n * a timeout.\n *\n * The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {String | Object | Buffer} [data]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Number}\n * @api public\n */\nClient.prototype.request = function (subject, data, options, callback) {\n  if (this.options.useOldRequestStyle) {\n    // noinspection JSDeprecatedSymbols\n    return this.oldRequest(subject, data, options, callback)\n  }\n  const args = callbackShifter(4, Array.prototype.slice.call(arguments))\n  subject = args[0]\n  data = args[1]\n  options = args[2] || {}\n  callback = args[3]\n\n  if (this.handledInvalidArgs({ subject, data, options, callback })) {\n    return 0\n  }\n\n  if (this.handledClosedOrDraining(callback)) {\n    return 0\n  }\n\n  const conf = this.initMuxRequestDetails(callback, options.max)\n  this.publish(subject, data, conf.inbox)\n\n  if (options.timeout) {\n    conf.timeout = setTimeout(() => {\n      if (conf.callback) {\n        conf.callback(new NatsError(REQ_TIMEOUT_MSG_PREFIX + conf.id, REQ_TIMEOUT))\n      }\n      this.cancelMuxRequest(conf.token)\n    }, options.timeout)\n  }\n\n  return conf.id\n}\n\n/**\n * @deprecated\n * @api private\n */\nClient.prototype.oldRequest = function (subject, data, options, callback) {\n  const args = callbackShifter(4, Array.prototype.slice.call(arguments))\n  subject = args[0]\n  data = args[1]\n  options = args[2] || {}\n  callback = args[3]\n\n  if (this.handledInvalidArgs({ subject, data, options, callback })) {\n    return 0\n  }\n\n  if (this.handledClosedOrDraining(callback)) {\n    return 0\n  }\n\n  const inbox = this.createInbox()\n  const s = this.subscribe(inbox, options, function (msg, reply) {\n    callback(msg, reply)\n  })\n  this.publish(subject, data, inbox)\n  return s\n}\n\n/**\n * Publish a message with an implicit inbox listener as the reply. Message is optional.\n * This should be treated as a subscription. The subscription is auto-cancelled after the\n * first reply is received or the timeout in millisecond is reached.\n *\n * If a timeout is reached, the callback is invoked with a NatsError with it's code set to\n * `REQ_TIMEOUT` on the first argument of the callback function, and the subscription is\n * cancelled.\n *\n * The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {String | Object | Buffer} [data]\n * @param {Object} [options]\n * @param {Number} timeout\n * @param {Function} callback - can be called with message or NatsError if the request timed out.\n * @return {Number}\n * @api public\n */\nClient.prototype.requestOne = function (subject, data, options, timeout, callback) {\n  if (this.options.useOldRequestStyle) {\n    // noinspection JSDeprecatedSymbols\n    return this.oldRequestOne(subject, data, options, timeout, callback)\n  }\n  const args = callbackShifter(5, Array.prototype.slice.call(arguments))\n  subject = args[0]\n  data = args[1]\n  options = args[2]\n  timeout = args[3]\n  callback = args[4]\n\n  if (timeout === undefined && typeof options === 'number') {\n    timeout = options\n    options = undefined\n  }\n\n  if (timeout === undefined && options === undefined && typeof data === 'number') {\n    timeout = data\n    data = EMPTY\n  }\n\n  options = options || {}\n  options.max = 1\n  options.timeout = timeout\n\n  return this.request(subject, data, options, callback)\n}\n\n// finds the last index that satisfies the testFn in array a\nfunction lastIndexOf (a, testFun) {\n  const idx = a.length - 1\n  for (let i = idx; i > -1; i--) {\n    if (testFun(a[i])) {\n      return i\n    }\n  }\n  return -1\n}\n\n// returns an array that shifts the last function in the\n// array to the last element of the array\nfunction callbackShifter (maxArgs, args) {\n  // last argument is expected to be a function\n  const a = new Array(maxArgs)\n  const idx = lastIndexOf(args, (v) => typeof v === 'function')\n  const last = args.length - 1\n  if (typeof args[idx] === 'function' && last > idx) {\n    for (let i = idx + 1; i <= last; i++) {\n      if (args[i]) {\n        throw new NatsError('unknown arguments after callback', BAD_CALLBACK)\n      }\n    }\n  }\n\n  // found a function, at the last index\n  if (idx !== -1) {\n    a[maxArgs - 1] = args[idx]\n    for (let i = 0; i < idx; i++) {\n      a[i] = args[i]\n    }\n  } else {\n    for (let i = 0; i < args.length; i++) {\n      a[i] = args[i]\n    }\n  }\n  return a\n}\n// exported only for tests\nexports.callbackShifter = callbackShifter\n\n/**\n * Strips the prefix of the request reply to derive the token.\n * This is internal and only used by the new requestOne.\n *\n * @api private\n */\nClient.prototype.extractToken = function (subject) {\n  return subject.substr(this.respmux.inboxPrefixLen)\n}\n\n/**\n * Creates a subscription for the global inbox in the new requestOne.\n * Request tokens, timer, and callbacks are tracked here.\n *\n * @api private\n */\nClient.prototype.createResponseMux = function () {\n  if (!this.respmux) {\n    const inbox = this.createInbox()\n    const ginbox = inbox + '.*'\n    const sid = this.subscribe(ginbox, (msg, reply, subject) => {\n      const token = this.extractToken(subject)\n      const conf = this.getMuxRequestConfig(token)\n      if (conf) {\n        if (conf.callback) {\n          conf.callback(msg, reply)\n        }\n        if (Object.hasOwnProperty.call(conf, 'expected')) {\n          conf.received++\n          if (conf.received >= conf.expected) {\n            this.cancelMuxRequest(token)\n            this.emit('unsubscribe', sid, subject)\n          }\n        }\n      }\n    })\n    this.respmux = {}\n    this.respmux.inbox = inbox\n    this.respmux.inboxPrefixLen = inbox.length + 1\n    this.respmux.subscriptionID = sid\n    this.respmux.requestMap = {}\n    this.respmux.nextID = -1\n  }\n  return this.respmux.inbox\n}\n\n/**\n * Stores the request callback and other details\n *\n * @api private\n */\nClient.prototype.initMuxRequestDetails = function (callback, expected) {\n  const ginbox = this.createResponseMux()\n  const token = nuid.next()\n  const inbox = ginbox + '.' + token\n\n  const conf = {\n    token: token,\n    callback: callback,\n    inbox: inbox,\n    id: this.respmux.nextID--,\n    received: 0\n  }\n  if (expected > 0) {\n    conf.expected = expected\n  }\n\n  this.respmux.requestMap[token] = conf\n  return conf\n}\n\n/**\n * Returns the mux request configuration\n * @param token\n * @returns Object\n */\nClient.prototype.getMuxRequestConfig = function (token) {\n  // if the token is a number, we have a fake sid, find the request\n  if (typeof token === 'number') {\n    let entry = null\n    for (const p in this.respmux.requestMap) {\n      if (Object.hasOwnProperty.call(this.respmux.requestMap, p)) {\n        const v = this.respmux.requestMap[p]\n        if (v.id === token) {\n          entry = v\n          break\n        }\n      }\n    }\n    if (entry) {\n      // noinspection JSUnresolvedVariable\n      token = entry.token\n    }\n  }\n  return this.respmux.requestMap[token]\n}\n\n/**\n * Cancels the mux request\n *\n * @api private\n */\nClient.prototype.cancelMuxRequest = function (token) {\n  const conf = this.getMuxRequestConfig(token)\n  if (conf) {\n    if (conf.timeout) {\n      clearTimeout(conf.timeout)\n    }\n    // the token could be sid, so use the one in the conf\n    delete this.respmux.requestMap[conf.token]\n  }\n  return conf\n}\n\n/**\n * @deprecated\n * @api private\n */\nClient.prototype.oldRequestOne = function (subject, data, options, timeout, callback) {\n  // eslint-disable-next-line prefer-rest-params\n  const args = callbackShifter(5, Array.prototype.slice.call(arguments))\n  subject = args[0]\n  data = args[1]\n  options = args[2]\n  timeout = args[3]\n  callback = args[4]\n\n  if (timeout === undefined && typeof options === 'number') {\n    timeout = options\n    options = undefined\n  }\n\n  if (timeout === undefined && options === undefined && typeof data === 'number') {\n    timeout = data\n    data = EMPTY\n  }\n\n  options = options || {}\n  options.max = 1\n  options.timeout = timeout\n\n  const sid = this.request(subject, data, options, callback)\n  this.timeout(sid, timeout, 1, function () {\n    callback(new NatsError(REQ_TIMEOUT_MSG_PREFIX + sid, REQ_TIMEOUT))\n  })\n  return sid\n}\n\n/**\n * Report number of outstanding subscriptions on this connection.\n *\n * @return {Number}\n * @api public\n */\nClient.prototype.numSubscriptions = function () {\n  return Object.keys(this.subs).length\n}\n\n/**\n * Reconnect to the server.\n *\n * @api private\n */\nClient.prototype.reconnect = function () {\n  if (this.closed) {\n    return\n  }\n  this.currentServer.reconnects += 1\n  this.reconnects += 1\n  this.createConnection()\n  if (this.currentServer.didConnect === true) {\n    this.emit('reconnecting')\n  }\n  this.currentServer.lastConnect = Date.now()\n}\n\n/**\n * Setup a timer event to attempt reconnect.\n *\n * @api private\n */\nClient.prototype.scheduleReconnect = function () {\n  // Just return if no more servers\n  if (this.servers.length === 0) {\n    return\n  }\n  // Don't set reconnecting state if we are just trying\n  // for the first time.\n  if (this.wasConnected === true) {\n    this.reconnecting = true\n  }\n  // Only stall if we have connected before.\n  let wait = 0\n  if (this.servers[0].didConnect === true) {\n    wait = this.options.reconnectDelayHandler()\n  }\n  // Select a server to connect to - this will be\n  // the first server that meets the wait criteria\n  const now = Date.now()\n  let maxWait = wait\n  for (let i = 0; i < this.servers.length; i++) {\n    const srv = this.selectServer()\n    if (srv.reconnects >= this.options.maxReconnectAttempts && this.options.maxReconnectAttempts !== -1) {\n      // remove the server - we already tried connecting max number of times\n      this.servers.pop()\n      continue\n    }\n    if (srv.lastConnect === undefined) {\n      // never connected here, try it right away\n      this.reconnect()\n      return\n    }\n    if (srv.lastConnect + wait <= now) {\n      // tried before, but after the min wait, try right away\n      this.reconnect()\n      return\n    } else {\n      // find the smallest amount of time we have to wait to maybe reconnect\n      const m = (srv.lastConnect + wait - now)\n      if (maxWait > m) {\n        maxWait = m\n      }\n    }\n  }\n\n  if (this.servers.length === 0) {\n    // we have no more servers\n    this.cleanupTimers()\n    this.emit('close')\n    this.close()\n    return\n  }\n  // if we are here, we cannot yet reconnect, but can at maxWait\n  setTimeout(() => {\n    this.scheduleReconnect()\n  }, maxWait)\n}\n"]},"metadata":{},"sourceType":"script"}